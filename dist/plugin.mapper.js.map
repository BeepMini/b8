{
  "version": 3,
  "sources": ["../plugin.mapper.js"],
  "sourcesContent": ["const mapper = {\n\n\t// All loaded maps.\n\tmaps: [],\n\n\t// Currently active map.\n\tcurrentMapId: null,\n\n\t// Map of entity types to their handlers.\n\ttypes: {},\n\tsystems: {},\n\tactions: {},\n\tsettings: {},\n\tbg: {},\n\n\t// The player entity ID.\n\tplayer: null,\n\n\t// Cooldown timer for actions such as key presses.\n\tactionCooldown: 0,\n\n\n\t/**\n\t * Initialize and start the game with the provided map data.\n\t *\n\t * @param {Object} mapData - The map data object containing map layout, tiles, objects, and settings.\n\t * @returns {void}\n\t */\n\tplay: function( mapData ) {\n\n\t\tb8.Utilities.checkObject( 'mapData', mapData );\n\n\t\tmapper.load( mapData );\n\n\t\tb8.Scene.add( 'menu', mapper.sceneMenu );\n\t\tb8.Scene.add( 'game', mapper.sceneGame );\n\t\tb8.Scene.set( 'menu' );\n\n\t},\n\n\n\t/**\n\t * Update the game state.\n\t *\n\t * @param {number} dt - The delta time since the last update call.\n\t * @returns {void}\n\t */\n\tupdate: function( dt ) {\n\n\t\tb8.ECS.run( dt );\n\n\t\tmapper.actionCooldown -= dt;\n\t\tif ( mapper.actionCooldown < 0 ) mapper.actionCooldown = 0;\n\n\t},\n\n\n\t/**\n\t * Draw an actor at its location with optional offsets.\n\t *\n\t * @param {Object} actor - The actor entity with properties: id, col, row, fg, bg, animation.\n\t * @returns {void}\n\t */\n\tdrawActor: function( actor ) {\n\n\t\tconst screenPosition = mapper.camera.getScreenPosition( actor.col, actor.row );\n\n\t\tconst actorX = actor.col - screenPosition.col;\n\t\tconst actorY = actor.row - screenPosition.row;\n\n\t\t// Draw the actor at its position with the specified offset.\n\t\tb8.locate( actorX + offsetX, actorY + offsetY );\n\t\tb8.color( actor.fg, actor.bg );\n\t\tb8.drawActor( actor.id, actor.animation );\n\n\t},\n\n\n\t/**\n\t * Set a delay for key presses to prevent rapid actions.\n\t *\n\t * @returns {void}\n\t */\n\tdelayKeyPress: function() {\n\n\t\tmapper.actionCooldown = mapper.CONFIG.keyPressDelay;\n\n\t},\n\n\n\t/**\n\t * Set the player's walking animation based on movement direction.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @param {number} dx - The change in x (column) direction.\n\t * @param {number} dy - The change in y (row) direction.\n\t * @returns {void}\n\t */\n\tsetPlayerWalkAnimation: function( playerId, dx, dy ) {\n\n\t\tconst anim = b8.ECS.getComponent( playerId, 'CharacterAnimation' );\n\n\t\tif ( dy > 0 ) anim.name = 'move-down';\n\t\tif ( dy < 0 ) anim.name = 'move-up';\n\t\tif ( dx > 0 ) anim.name = 'move-right';\n\t\tif ( dx < 0 ) anim.name = 'move-left';\n\n\t\tanim.duration = 0.3;\n\n\t},\n\n\n\t/**\n\t * Render all entities on the screen with optional offsets.\n\t *\n\t * @param {number} offsetX - Horizontal offset for rendering.\n\t * @param {number} offsetY - Vertical offset for rendering.\n\t * @returns {void}\n\t */\n\trender: function( offsetX = 0, offsetY = 0 ) {\n\n\t\t// Handy caches so look-ups are O(1) inside the loop\n\t\tconst list = [];\n\n\t\tfor ( const id of b8.ECS.query( 'Sprite', 'Loc' ) ) {\n\t\t\tconst spr = b8.ECS.getComponent( id, 'Sprite' );\n\t\t\tconst loc = b8.ECS.getComponent( id, 'Loc' );\n\t\t\tconst anim = b8.ECS.getComponent( id, 'CharacterAnimation' );\n\t\t\tlist.push( { spr, loc, anim } );\n\t\t}\n\n\t\t// nothing to draw\n\t\tif ( list.length === 0 ) return;\n\n\t\t// Depth-sort (default depth = 0)\n\t\tlist.sort( ( a, b ) => ( a.spr.depth ?? 0 ) - ( b.spr.depth ?? 0 ) );\n\n\t\t// Draw\n\t\tfor ( const { spr, loc, anim } of list ) {\n\n\t\t\tconst pos = mapper.camera.getTilePosition( loc.col, loc.row );\n\n\t\t\tb8.locate( pos.col + offsetX, pos.row + offsetY );\n\t\t\tb8.color( spr.fg ?? 15, spr.bg ?? 0 );\n\n\t\t\tswitch ( spr.type ) {\n\n\t\t\t\tcase 'actor':\n\n\t\t\t\t\tlet nudgeCol = 0;\n\t\t\t\t\tlet nudgeRow = 0;\n\t\t\t\t\tif ( spr.nudgeCol ) nudgeCol = spr.nudgeCol;\n\t\t\t\t\tif ( spr.nudgeRow ) nudgeRow = spr.nudgeRow;\n\n\t\t\t\t\tb8.drawActor( parseInt( spr.tile ), anim.name, nudgeCol, nudgeRow );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vfx':\n\n\t\t\t\t\tb8.Vfx.draw( spr.id, spr.startTime );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tb8.printChar( parseInt( spr.tile ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Draw the visible portion of the current map to the screen.\n\t *\n\t * @returns {void}\n\t */\n\tdrawScreen: function() {\n\n\t\tif ( !mapper.isValidMapId( mapper.currentMapId ) ) {\n\t\t\tb8.Utilities.fatal( \"No current map set.\" );\n\t\t\treturn;\n\t\t}\n\n\t\tlet loc = b8.ECS.getComponent( mapper.player, 'Loc' );\n\t\tif ( !loc ) loc = { col: 0, row: 0 };\n\t\tconst screenPosition = mapper.camera.getScreenPosition( loc.col, loc.row );\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\tb8.Tilemap.draw(\n\t\t\tcurrentMap.mapData,\n\t\t\tscreenPosition.col,\n\t\t\tscreenPosition.row,\n\t\t\tscreenPosition.w,\n\t\t\tscreenPosition.h\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Set a tile at the specified coordinates in the current map.\n\t *\n\t * @param {number} x - The x-coordinate (column) of the tile to set.\n\t * @param {number} y - The y-coordinate (row) of the tile to set.\n\t * @param {string} tile - The tile character to set at the specified coordinates.\n\t * @returns {void}\n\t */\n\tsetTile: function( x, y, tile ) {\n\n\t\tif ( !mapper.currentMap ) {\n\t\t\tb8.Utilities.error( \"No current map set.\" );\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tx < 0 ||\n\t\t\ty < 0 ||\n\t\t\ty >= mapper.currentMap.map.mapHeight ||\n\t\t\tx >= mapper.currentMap.map.mapWidth\n\t\t) {\n\t\t\tb8.Utilities.error( \"Mapper.setTile, coordinates out of bounds.\" );\n\t\t\treturn;\n\t\t}\n\n\t\tmapper.currentMap.map[ y ][ x ] = tile;\n\n\t},\n\n\n\t/**\n\t * Get the action verb for a given entity ID.\n\t *\n\t * @param {number} id - The entity ID to get the verb for.\n\t * @returns {string} The action verb associated with the entity, or an empty string if none exists.\n\t */\n\tgetVerbForEntity: ( id ) => {\n\n\t\tconst a = b8.ECS.getComponent( id, 'Action' );\n\t\treturn a?.verb ?? '';\n\n\t},\n\n\n\t/**\n\t * Get the currently active map.\n\t *\n\t * @returns {Object} The current map object.\n\t */\n\tgetCurrentMap: () => {\n\n\t\treturn mapper.maps[ mapper.currentMapId ];\n\n\t},\n\n\n\t/**\n\t * Get the action verb for the entity directly in front of the player.\n\t *\n\t * @param {number} playerId - The player entity ID.\n\t * @returns {string} The action verb of the entity ahead, or an empty string if none exists.\n\t */\n\tpromptAhead: ( playerId ) => {\n\n\t\tconst ids = mapper.entitiesAhead( playerId );\n\t\tfor ( const id of ids ) {\n\t\t\tconst verb = mapper.getVerbForEntity( id );\n\t\t\tif ( verb ) return verb;\n\t\t}\n\t\treturn '';\n\n\t},\n\n\n\t/**\n\t * Get the tile coordinates directly in front of the player.\n\t *\n\t * @param {number} playerId - The player entity ID.\n\t * @returns {Object} An object with x and y properties representing the tile coordinates ahead of the player.\n\t */\n\tahead: ( playerId ) => {\n\n\t\tconst loc = b8.ECS.getComponent( playerId, 'Loc' );\n\t\tconst dir = b8.ECS.getComponent( playerId, 'Direction' ); // {dx,dy}\n\n\t\tif ( !loc || !dir ) return { x: 0, y: 0 };\n\n\t\tconst x = loc.col + ( dir.dx || 0 );\n\t\tconst y = loc.row + ( dir.dy || 0 );\n\t\treturn { x, y };\n\n\t},\n\n\n\t/**\n\t * Get all entities located directly in front of the player.\n\t *\n\t * @param {number} playerId - The player entity ID.\n\t * @returns {Array} An array of entity IDs located ahead of the player.\n\t */\n\tentitiesAhead: ( playerId ) => {\n\n\t\tconst { x, y } = mapper.ahead( playerId );\n\t\treturn b8.ECS.entitiesAt( x, y ) ?? [];\n\n\t},\n\n\n\t/**\n\t * Handle collision when the player attempts to move to a new tile.\n\t *\n\t * @param {number} x - The current x-coordinate (column) of the player.\n\t * @param {number} y - The current y-coordinate (row) of the player.\n\t * @param {number} newCol - The target x-coordinate (column) the player is moving to.\n\t * @param {number} newRow - The target y-coordinate (row) the player is moving to.\n\t * @param {number} dx - The change in x (column) direction.\n\t * @param {number} dy - The change in y (row) direction.\n\t * @return {boolean} True if the movement is blocked by a collision, false otherwise.\n\t */\n\tdoCollision: function( x, y, newCol, newRow, dx, dy ) {\n\n\t\t// ECS collision.\n\t\tif ( mapper.systems.tryPushing( x, y, dx, dy ) ) return true;\n\n\t\t// every entity occupying the target tile\n\t\tfor ( const id of b8.ECS.entitiesAt( newCol, newRow ) ) {\n\n\t\t\tconst typeComp = b8.ECS.getComponent( id, 'Type' );\n\t\t\tconst handler = typeComp ? mapper.types[ typeComp.name ] : null;\n\n\t\t\tif ( handler?.onCharacterCollision ) {\n\t\t\t\tconst blocked = handler.onCharacterCollision( id, newCol, newRow, dx, dy );\n\t\t\t\tif ( blocked ) return true;\n\t\t\t}\n\n\t\t\tconst isSolid = b8.ECS.hasComponent( id, 'Solid' );\n\t\t\tif ( isSolid ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\n\t/**\n\t * Perform the action associated with the entity directly in front of the player.\n\t *\n\t * @param {number} playerId - The player entity ID.\n\t * @returns {void}\n\t */\n\tdoAction: ( playerId ) => {\n\n\t\tif ( mapper.actionCooldown > 0 ) return;\n\n\t\tconst action = mapper.promptAhead( playerId );\n\n\t\tif ( action && mapper.actions[ action ] ) {\n\t\t\tmapper.actions[ action ]( playerId );\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Perform an attack action for the specified player.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @returns {void}\n\t */\n\tdoAttack: ( playerId ) => {\n\n\t\tconst ahead = mapper.ahead( playerId );\n\t\tconst ids = mapper.entitiesAhead( playerId );\n\n\t\tmapper.types.vfx.spawn(\n\t\t\tahead.x, ahead.y,\n\t\t\t{ id: 'swipe', fg: 15, bg: 0 }\n\t\t);\n\n\t\tfor ( const targetId of ids ) {\n\n\t\t\t// Don't attack self.\n\t\t\tif ( targetId === playerId ) continue;\n\n\t\t\t// Only attack entities that can be attacked.\n\t\t\tif ( !b8.ECS.hasComponent( targetId, 'AttackTarget' ) ) continue;\n\n\t\t\t// Apply damage to the target.\n\t\t\tconst targetHealth = b8.ECS.getComponent( targetId, 'Health' );\n\t\t\tconst playerAttack = b8.ECS.getComponent( playerId, 'Attack' ) || { value: 1 };\n\t\t\ttargetHealth.value -= playerAttack.value;\n\n\t\t\t// Check if target is defeated.\n\t\t\tif ( targetHealth.value <= 0 ) {\n\t\t\t\tb8.ECS.removeEntity( targetId );\n\t\t\t\tmapper.types.vfx.spawn(\n\t\t\t\t\tahead.x, ahead.y,\n\t\t\t\t\t{ id: 'skull', fg: 2, bg: 0, offsetTime: 200 }\n\t\t\t\t);\n\n\t\t\t\t// Small pause on defeat.\n\t\t\t\tmapper.updateMoveDelay( 0.6 );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Only attack one target at a time.\n\t\t\tbreak;\n\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Update the move delay to control player movement speed.\n\t *\n\t * @param {number} amount - The amount of delay to set (in seconds).\n\t * @returns {void}\n\t */\n\tupdateMoveDelay: function( amount = mapper.CONFIG.moveDelay ) {\n\n\t\t// We use Math.max to ensure we don't reduce an existing longer delay.\n\t\tmapper.sceneGame.moveDelay = Math.max( amount, mapper.sceneGame.moveDelay );\n\n\t},\n\n\n\t/**\n\t * Check if the provided map ID is valid.\n\t *\n\t * @param {number} mapId - The map ID to validate.\n\t * @returns {boolean} True if the map ID is valid, false otherwise.\n\t */\n\tisValidMapId: ( mapId ) => {\n\n\t\treturn typeof mapId === 'number' && mapId >= 0;\n\n\t},\n\n\n\t/**\n\t * Remove an object of a specific type at the given coordinates from the current map.\n\t *\n\t * @param {number} col - The column coordinate of the object to remove.\n\t * @param {number} row - The row coordinate of the object to remove.\n\t * @param {string} type - The type of the object to remove.\n\t * @returns {void}\n\t */\n\tremoveObjectAt: function( col, row, type ) {\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\t// Filter out the object matching the specified coordinates and type.\n\t\tcurrentMap.objects = currentMap.objects.filter(\n\t\t\t( obj ) => !( obj.x === col && obj.y === row && obj.type.startsWith( type ) )\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Change the type of an object at the given coordinates in the current map.\n\t *\n\t * @param {number} col - The column coordinate of the object to change.\n\t * @param {number} row - The row coordinate of the object to change.\n\t * @param {string} type - The current type of the object to change.\n\t * @param {string} newType - The new type to set for the object.\n\t * @returns {void}\n\t */\n\tchangeObjectTypeAt: function( col, row, type, newType ) {\n\n\t\tconsole.log( 'changeObjectTypeAt', col, row, type, newType );\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\t// Find the object matching the specified coordinates and type.\n\t\tfor ( const obj of currentMap.objects ) {\n\t\t\tif ( obj.x === col && obj.y === row && obj.type.startsWith( type ) ) {\n\t\t\t\tobj.type = newType;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Give rewards to the player.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @param {Array} rewards - An array of reward objects to give to the player.\n\t * @returns {void}\n\t */\n\tgiveRewards: function( playerId, rewards = [] ) {\n\n\t\tif ( !rewards || rewards.length === 0 ) return;\n\n\t\trewards.forEach(\n\t\t\t( reward ) => {\n\n\t\t\t\tif ( !reward.type ) return;\n\t\t\t\tif ( !reward.props ) reward.props = {};\n\n\t\t\t\tconst fn = mapper.types[ reward.type ]?.pickupHandler;\n\t\t\t\tif ( fn ) fn( playerId, reward );\n\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\n\n};\n\n\nmapper.CONFIG = {\n\n\t// Time in seconds for player movement delay.\n\tmoveDelay: 0.2,\n\n\t// Key press delay.\n\tkeyPressDelay: 0.25,\n\n\t/**\n\t * Offset to apply when drawing the map and actors.\n\t * This is to account for any borders or UI elements.\n\t */\n\tmapOffsetX: 1,\n\tmapOffsetY: 1,\n\n\t// UI graphics.\n\tgameUI: `hpgYhRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGJUHAACghRiVBwAAoIUYlQcAAKCFGJUKAACgmBiFGBwHBgCghRgZBwYAoIUYGQcGAKCFGBkHBgCghRgZBwYAoIUYGQcGAKCFDAYHAKCFGBkHBgCghRgZBwYAoIUYGQcGAKCFGBkHBgCghRgZBwYAoIUYGQcGAKCFGBkHBgCghRgZBwYAoIUYGQcGAKCFGBkHBgCghRgZBwYAoIUYGQcGAKCFGB0HBgCghRgZBwgAoIUYIAgHAKCFGCsHBgCghRkBXAoAAKCYGIUYKwYHAKCFEgAHAKCFAAgAAKCFAAgAAKCFAAgAAKCFAwEAAKCFAAgAAKCFAA8AAKCFEwAHAKCFAQcGAKCFGQG0CgcAoIUBBwYAoIUBBwYAoIUBBwYAoIUZAbUKBwCghQEHBgCghQEHBgCghQEHBgCghQEHBgCghREGBwCghQAAAACghRMABwCghRgrBwYAoIUZAV4KAACgmBiFGCsGBwCghQEABwCghRkBnwgAAKCFGQGfCAAAoIUZAZ8IAACghRkBnwgAAKCFGQGfCAAAoIUZAZ8IAACghQEABwCghRg9AAEAoIUYPQABAKCFGD0AAQCghRg9AAEAoIUYPQABAKCFGD0AAQCghRg9AAEAoIUYPQABAKCFGD4AAQCghQEHBgCghRgrBwYAoIUAAAAAoIUAAAAAoIUYKwcGAKCFGQFdCgAAoJgYhRgrBgcAoIUBAAcAoIUBAAEAoIUADgAAoIUADwAAoIUADwAAoIUADwAAoIUADwAAoIUAAQAAoIUABQEAoIUBAQcAoIUBAQcAoIUBAQcAoIUBAQcAoIUBAQcAoIUBAQcAoIUBAQcAoIUYUAABAKCFAAYHAKCFGCsHBgCghQAAAACghRglAAcAoIUYKwcGAKCFGQFeCgAAoJgYhRguBwYAoIUBAAEAoIUAAQAAoIUAAQAAoIUAAQAAoIUAAQAAoIURAQAAoIURAQAAoIUBAAEAoIUYYQABAKCFGGEAAQCghRhhAAEAoIUYYQABAKCFGGEAAQCghRhhAAEAoIURBgEAoIURBgEAoIUYYgABAKCFEQYHAKCFGC8HBgCghRgZBgcAoIUYGQYHAKCFGDEHBgCghRkBXQoAAKA=`,\n\n};\n\n\nmapper.actions.open = async function( playerId ) {\n\n\tconst entities = mapper.entitiesAhead( playerId );\n\n\tfor ( const id of entities ) {\n\n\t\tconst obj = b8.ECS.getComponent( id, 'Openable' );\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\n\t\tif ( !obj || !sprite ) continue;\n\n\t\t// Change the tile.\n\t\tif ( obj.openedTile ) sprite.tile = obj.openedTile;\n\n\t\t// Change the master map object type if specified.\n\t\t// This prevents re-opening the chest on when reloading the map.\n\t\tif ( obj.newType ) {\n\t\t\tconst loc = b8.ECS.getComponent( id, 'Loc' );\n\t\t\tconst type = b8.ECS.getComponent( id, 'Type' );\n\t\t\tmapper.changeObjectTypeAt( loc.col, loc.row, type.name, obj.newType );\n\t\t}\n\n\t\t// Play sound effect.\n\t\tb8.Sfx.play( 'tone/jingle/017' );\n\n\t\t// Rewards.\n\t\tconst rewards = b8.ECS.getComponent( id, 'Reward' );\n\t\tmapper.giveRewards( playerId, rewards?.items || [] );\n\n\t\t// Clean up components.\n\t\tb8.ECS.removeComponent( id, 'Reward' );\n\t\tb8.ECS.removeComponent( id, 'Action' );\n\t\tb8.ECS.removeComponent( id, 'Openable' );\n\n\t\t// If message then change the entity to a Signpost entity and change the\n\t\t// action verb to read.\n\t\tconst messageComponent = b8.ECS.getComponent( id, 'Message' );\n\t\tif ( messageComponent?.message?.length > 0 ) {\n\t\t\tb8.ECS.addComponent( id, 'Action', { verb: 'read' } );\n\t\t}\n\n\t\tmapper.delayKeyPress();\n\n\t\treturn;\n\n\t}\n\n};\nmapper.actions.pull = function( playerId ) {\n\n\tconst loc = b8.ECS.getComponent( playerId, 'Loc' );\n\tconst dir = b8.ECS.getComponent( playerId, 'Direction' ); // {dx,dy}\n\n\tmapper.systems.tryPulling( loc.col, loc.row, dir.dx, dir.dy, playerId );\n\n};\nmapper.actions.read = async function( playerId ) {\n\n\tconst entities = mapper.entitiesAhead( playerId );\n\n\tfor ( const id of entities ) {\n\n\t\tconst obj = b8.ECS.getComponent( id, 'Message' );\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\n\t\tif ( !obj || !sprite ) continue;\n\n\t\tb8.color(\n\t\t\tsprite.fg ?? 15,\n\t\t\tsprite.bg ?? 5\n\t\t);\n\n\t\tconst message = mapper.helpers.processChatText( obj.message || '' );\n\t\tawait b8.Async.dialogTypewriter( message, [ \"OK\" ], 20 );\n\n\t\tmapper.delayKeyPress();\n\n\t\treturn;\n\n\t}\n\n};\nmapper.camera = {\n\n\t/**\n\t * Get the top-left tile coordinates of the screen the player is currently on.\n\t *\n\t * @param {number} pCol - The player's column position.\n\t * @param {number} pRow - The player's row position.\n\t * @returns {Object} An object with col, row, w, and h properties representing the screen's top-left tile and dimensions.\n\t */\n\tgetScreenPosition: function( pCol, pRow ) {\n\n\t\tif ( !mapper.isValidMapId( mapper.currentMapId ) ) {\n\t\t\tb8.Utilities.error( \"No current map set.\" );\n\t\t\treturn { col: 0, row: 0 };\n\t\t}\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\tconst screenWidth = currentMap.screenWidth;\n\t\tconst screenHeight = currentMap.screenHeight;\n\n\t\t// Calculate which screen to draw based on player position.\n\t\tconst screenX = Math.floor( pCol / screenWidth ) * screenWidth;\n\t\tconst screenY = Math.floor( pRow / screenHeight ) * screenHeight;\n\n\t\treturn { col: screenX, row: screenY, w: screenWidth, h: screenHeight };\n\n\t},\n\n\n\t/**\n\t * Get the on-screen tile coordinates for a given map tile.\n\t *\n\t * @param {number} col - The map tile's column position.\n\t * @param {number} row - The map tile's row position.\n\t * @returns {Object} An object with col and row properties representing the tile's on-screen position.\n\t */\n\tgetTilePosition: function( col, row ) {\n\n\t\tconst loc = b8.ECS.getComponent( mapper.player, 'Loc' );\n\t\tconst pos = mapper.camera.getScreenPosition( loc.col, loc.row );\n\n\t\tlet tileCol = col - pos.col;\n\t\tlet tileRow = row - pos.row;\n\n\t\t// If out of bounds push off the screen to avoid rendering.\n\t\tif ( tileCol < 0 ) tileCol = -100;\n\t\tif ( tileRow < 0 ) tileRow = -100;\n\t\tif ( tileCol >= pos.w ) tileCol = -100;\n\t\tif ( tileRow >= pos.h ) tileRow = -100;\n\n\t\treturn {\n\t\t\tcol: tileCol,\n\t\t\trow: tileRow,\n\t\t};\n\n\t},\n\n};\nmapper.collision = {\n\n\t/**\n\t * Check if there is a solid object at (col,row).\n\t *\n\t * @param {number} col\n\t */\n\tisSolidAt: ( col, row ) => {\n\n\t\treturn b8.ECS.entitiesAt( col, row ).some( id => b8.ECS.hasComponent( id, 'Solid' ) );\n\n\t},\n\n\n\t/**\n\t * Check if (col,row) is free (walkable and no solid object).\n\t *\n\t * @param {number} col\n\t * @param {number} row\n\t * @returns {boolean}\n\t */\n\tisFree: ( col, row ) => {\n\n\t\treturn mapper.collision.isWalkable( col, row ) && !mapper.collision.isSolidAt( col, row );\n\n\t},\n\n\n\t/**\n\t * Check if (col,row) is walkable (not a wall or closed door).\n\t *\n\t * @param {number} col\n\t * @param {number} row\n\t * @returns {boolean}\n\t */\n\tisWalkable: function( col, row ) {\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\t// Check bounds.\n\t\tif (\n\t\t\tcol < 0 ||\n\t\t\trow < 0 ||\n\t\t\tcol >= currentMap.mapWidth ||\n\t\t\trow >= currentMap.mapHeight\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check current tile collision properties.\n\t\tlet mapCell = currentMap.mapData[ row ][ col ];\n\t\tif ( true === mapCell[ 3 ] ) return false;\n\n\t\t// Check for spikes.\n\t\t// if ( cell === '^' ) {\n\t\t// \tlet spike = Tile.spikes.list.find( s => s.x === x && s.y === y );\n\t\t// \tif ( spike && spike.up ) {\n\t\t// \t\treturn false;\n\t\t// \t}\n\t\t// }\n\n\t\treturn true;\n\n\t},\n\n};\nmapper.helpers = {\n\n\t/**\n\t * Capitalize the first letter of each word in a string.\n\t *\n\t * @param {string} str Input string\n\t * @returns {string} Capitalized string\n\t */\n\tcapitalizeWords: ( str ) => {\n\n\t\treturn str.replace( /\\b\\p{L}/gu, c => c.toUpperCase() )\n\n\t},\n\n\n\t/**\n\t * Process chat text, replacing tokens with dynamic values.\n\t *\n\t * @param {string} str Input string\n\t * @returns {string} Processed string\n\t */\n\tprocessChatText: ( str ) => {\n\n\t\t// Replace [levelName] with the actual level name.\n\t\tstr = str.replace( /\\[levelName\\]/g, b8.data.levelName ?? 'Unknown' );\n\n\t\t// Replace [playerName] with the actual player name.\n\t\tstr = str.replace( /\\[playerName\\]/g, b8.data.playerName ?? 'Player' );\n\n\t\t// Replace [totalCoins] with the actual total coins value.\n\t\tstr = str.replace( /\\[totalCoins\\]/g, b8.data.totalCoins ?? '0' );\n\n\t\treturn str;\n\n\t},\n\n\n\t/**\n\t * Get all map objects of a given type.\n\t *\n\t * @param {string} type The object type to search for.\n\t * @returns {Object[]} Array of matching objects.\n\t */\n\tgetObjectsByType: ( type ) => {\n\n\t\tconst objects = [];\n\n\t\tfor ( let l = 0; l < mapper.maps.length; l++ ) {\n\t\t\tconst map = mapper.maps[ l ];\n\t\t\tfor ( const obj of map.objects ) {\n\t\t\t\t// Support type prefixes, e.g., \"door\" matches \"doorway\", \"doorLarge\", etc.\n\t\t\t\tif ( obj.type.startsWith( type ) ) objects.push( obj );\n\t\t\t}\n\t\t}\n\n\t\treturn objects;\n\n\t},\n\n}\n/**\n * Load a map into the game.\n *\n * @param {Object} mapData - The map data object containing map layout, tiles, objects, and settings.\n * @returns {void}\n */\nmapper.load = function( mapData ) {\n\n\t// It's a new game so reset everything.\n\tb8.ECS.reset();\n\tmapper.maps = [];\n\tmapper.settings = {};\n\tmapper.currentMapId = null;\n\n\tb8.Utilities.checkObject( 'mapData', mapData );\n\n\tif ( mapData.version === 1 ) mapData = mapper.upgradeMapDataV1toV2( mapData );\n\n\tmapper.settings = { ...mapData.settings };\n\tb8.Utilities.checkObject( 'mapper.settings', mapper.settings );\n\n\t// Loop through levels and set them up.\n\tmapData.levels.forEach(\n\t\t( level, index ) => {\n\n\t\t\tconst mapDataString = level.mapData.join( '\\n' );\n\t\t\tb8.Utilities.checkString( `mapDataString for level ${index}`, mapDataString );\n\n\t\t\tconst maze = b8.Tilemap.convertFromText( mapDataString );\n\t\t\tconst map = b8.Tilemap.createFromArray( maze, mapData.tiles );\n\n\t\t\t// Add mapId to each object\n\t\t\tconst objects = ( level.objects || [] ).map(\n\t\t\t\tobj => ( { ...obj, mapId: index } )\n\t\t\t);\n\n\t\t\tmapper.maps.push(\n\t\t\t\t{\n\t\t\t\t\t\"screenWidth\": mapData.screenWidth,\n\t\t\t\t\t\"screenHeight\": mapData.screenHeight,\n\t\t\t\t\t\"screenCountX\": level.screenCountX,\n\t\t\t\t\t\"screenCountY\": level.screenCountY,\n\t\t\t\t\t\"objects\": objects,\n\t\t\t\t\t\"mapWidth\": map[ 0 ].length,\n\t\t\t\t\t\"mapHeight\": map.length,\n\t\t\t\t\t\"mapData\": map,\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\t);\n\n\t// Set game name.\n\t// Some settings use this, for things like local storage keys.\n\tif ( mapper.settings.gameName ) {\n\t\tb8.CONFIG.NAME = mapper.settings.gameName;\n\t}\n\n\t// Setup player.\n\tmapper.player = b8.ECS.create(\n\t\t{\n\t\t\tType: { name: 'player' },\n\t\t\tLoc: { row: 0, col: 0 },\n\t\t\tDirection: { dx: 0, dy: 1 },\n\t\t\tSprite: {\n\t\t\t\ttype: 'actor',\n\t\t\t\ttile: parseInt( mapper.settings.character ) || 6,\n\t\t\t\tfg: parseInt( mapper.settings.characterColor ) || 10,\n\t\t\t\tbg: 0,\n\t\t\t\tdepth: 100,\n\t\t\t},\n\t\t\tSolid: {},\n\t\t\tCharacterAnimation: {\n\t\t\t\tname: 'idle',\n\t\t\t\tdefault: 'idle',\n\t\t\t\tduration: 0,\n\t\t\t},\n\t\t\tHealth: {\n\t\t\t\tvalue: 2,\n\t\t\t\tmax: 12\n\t\t\t},\n\t\t\tAttack: {\n\t\t\t\tvalue: 1\n\t\t\t},\n\t\t}\n\t);\n\n\t// This sets the map and then loads the objects.\n\tmapper.setCurrentMap( 0 );\n\n\t// Count all coin objects.\n\t// Loop through all levels and count coins\n\tlet coinCount = 0;\n\tfor ( const level of mapper.maps ) {\n\t\tcoinCount += level.objects.filter( obj => obj.type === 'coin' ).length;\n\t}\n\tb8.data.totalCoins = coinCount;\n\n\t// Add systems.\n\tb8.ECS.addSystem( 'characterAnimation', mapper.systems.characterAnimation );\n\tb8.ECS.addSystem( 'pathFollower', mapper.systems.pathFollower );\n\tb8.ECS.addSystem( 'sprite', mapper.systems.sprite );\n\tb8.ECS.addSystem( 'bumpAttack', mapper.systems.bumpAttack );\n\tb8.ECS.addSystem( 'pickup', mapper.systems.pickup );\n\tb8.ECS.addSystem( 'vfx', mapper.systems.vfx );\n\n\t// Play music.\n\tif ( mapper.settings.bgm ) b8.Music.play( mapper.settings.bgm );\n\n\t// Validate map data.\n\tif (\n\t\tmapper.settings.splash &&\n\t\tmapper.settings.splash.length > 10 &&\n\t\tb8.Tilemap.validateTilemap( mapper.settings.splash )\n\t) {\n\n\t\tmapper.bg.splash = b8.Tilemap.load( mapper.settings.splash );\n\n\t}\n\n};\n\n\n/**\n * Upgrade map data from version 1 to version 2.\n *\n * @param {Object} mapData - The map data object in version 1 format.\n * @returns {Object} The upgraded map data object in version 2 format.\n */\nmapper.upgradeMapDataV1toV2 = function( mapData ) {\n\n\tconst level = {\n\t\tmapData: [ ...mapData.map ],\n\t\tobjects: [ ...mapData.objects ],\n\t\tscreenCountX: mapData.screenCountX,\n\t\tscreenCountY: mapData.screenCountY,\n\t};\n\n\t// Create a levels object.\n\tmapData.levels = [ level ];\n\n\t// Update version.\n\tmapData.version = 2;\n\n\t// Unset old properties.\n\tdelete mapData.map;\n\tdelete mapData.objects;\n\tdelete mapData.screenCountX;\n\tdelete mapData.screenCountY;\n\n\treturn mapData;\n\n};\n\n\n/**\n * Set the current active map by name.\n *\n * @param {string} mapName - The name of the map to set as current.\n * @returns {void}\n */\nmapper.setCurrentMap = function( mapId ) {\n\n\tb8.Utilities.checkInt( 'mapId', mapId );\n\n\tif ( mapId < 0 || mapId >= mapper.maps.length ) {\n\t\tb8.Utilities.fatal( `Map ID \"${mapId}\" is out of bounds.` );\n\t\treturn;\n\t}\n\n\t// Check if already on this map.\n\tif ( mapId === mapper.currentMapId ) return;\n\n\tlet currentMap = mapper.maps[ mapId ];\n\n\t// Add objects.\n\tif ( !currentMap.objects ) currentMap.objects = [];\n\n\t// Delete all ecs entities except the player.\n\tconst allEntities = b8.ECS.getAllEntities();\n\tfor ( const entityId of allEntities ) {\n\n\t\tconst typeComp = b8.ECS.getComponent( entityId, 'Type' );\n\t\tif ( typeComp?.name === 'player' ) continue;\n\t\tb8.ECS.removeEntity( entityId );\n\n\t}\n\n\t// Spawn all objects for the current map.\n\tfor ( const obj of currentMap.objects ) {\n\n\t\tconst handler = mapper.types[ obj.type ];\n\t\tif ( handler?.spawn ) handler.spawn( obj.x, obj.y, obj.props );\n\n\t}\n\n\t// Set current map id.\n\tmapper.currentMapId = mapId;\n\n\t// Delete any start objects from the current map.\n\t// It's no longer needed.\n\tmapper.maps[ mapper.currentMapId ].objects = mapper.maps[ mapper.currentMapId ].objects.filter(\n\t\tobj => obj.type !== 'start'\n\t);\n\n};\n\nmapper.menu = {\n\n\t/**\n\t * Get the instructions text.\n\t *\n\t * @returns {string} The instructions text.\n\t */\n\tgetInstructions: function() {\n\n\t\tif ( mapper.hasInstructions() ) {\n\t\t\treturn mapper.settings.instructions;\n\t\t}\n\t\treturn '';\n\n\t},\n\n\n\t/**\n\t * Check if there are instructions available.\n\t *\n\t * @returns {boolean} True if instructions are available, false otherwise.\n\t */\n\thasInstructions: function() {\n\n\t\treturn !!mapper.settings.instructions;\n\n\t},\n\n\n\t/**\n\t * Get the credits text.\n\t *\n\t * @returns {string} The credits text.\n\t */\n\tgetCredits: function() {\n\n\t\tif ( mapper.hasCredits() ) {\n\t\t\treturn mapper.settings.credits;\n\t\t}\n\n\t\treturn '';\n\n\t},\n\n\n\t/**\n\t * Check if there are credits available.\n\t *\n\t * @returns {boolean} True if credits are available, false otherwise.\n\t */\n\thasCredits: function() {\n\n\t\treturn !!mapper.settings.credits;\n\n\t},\n\n\n\t/**\n\t * Draw the splash screen.\n\t *\n\t * @returns {void}\n\t */\n\tdrawSplash: function() {\n\n\t\tif ( mapper.bg.splash ) {\n\t\t\tb8.Tilemap.draw( mapper.bg.splash );\n\n\t\t\t// b8 Logo\n\t\t\tb8.locate( b8.CONFIG.SCREEN_COLS - 1, b8.CONFIG.SCREEN_ROWS - 1 );\n\t\t\tb8.color( 15, 0 );\n\t\t\tb8.printChar( 88 );\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Check if there is a splash screen available.\n\t *\n\t * @returns {boolean} True if a splash screen is available, false otherwise.\n\t */\n\thasSplash: function() {\n\n\t\treturn !!mapper.bg.splash;\n\n\t},\n\n};\nmapper.sceneGame = {\n\n\tUI: null,\n\n\tmoveDelay: 0.15,\n\n\n\t/**\n\t * Initialize the game scene.\n\t *\n\t * @returns {void}\n\t */\n\tinit: function() {\n\n\t\tmapper.sceneGame.UI = b8.Tilemap.load( mapper.CONFIG.gameUI );\n\n\t},\n\n\n\t/**\n\t * Update the game scene.\n\t *\n\t * @param {number} dt Delta time in seconds since last frame.\n\t * @returns {void}\n\t */\n\tupdate: function( dt ) {\n\n\t\t// Update systems.\n\t\tmapper.update( dt );\n\n\t\tmapper.sceneGame.moveDelay -= dt;\n\t\tif ( mapper.sceneGame.moveDelay > 0 ) return;\n\n\t\t// Get player components\n\t\tconst loc = b8.ECS.getComponent( mapper.player, 'Loc' );\n\n\t\tlet dx = 0, dy = 0, keyPressed = false;\n\n\t\t// Calculate direction of movement.\n\t\t// Use else if so we can only move in one direction at a time and not jump\n\t\t// over collision walls diagonally.\n\t\tif ( b8.key( \"ArrowUp\" ) ) { dy = -1; keyPressed = true; }\n\t\telse if ( b8.key( \"ArrowDown\" ) ) { dy = 1; keyPressed = true; }\n\t\telse if ( b8.key( \"ArrowLeft\" ) ) { dx = -1; keyPressed = true; }\n\t\telse if ( b8.key( \"ArrowRight\" ) ) { dx = 1; keyPressed = true; }\n\t\tif ( b8.key( \"ButtonA\" ) ) { mapper.doAttack( mapper.player ); keyPressed = true; }\n\t\tif ( b8.key( \"ButtonB\" ) ) { mapper.doAction( mapper.player ); keyPressed = true; }\n\n\t\t// Update move delay when a key is pressed.\n\t\tif ( keyPressed ) mapper.updateMoveDelay();\n\n\t\t// Move player.\n\t\tif ( dx !== 0 || dy !== 0 ) {\n\n\t\t\tlet newCol = loc.col + dx;\n\t\t\tlet newRow = loc.row + dy;\n\n\t\t\tmapper.setPlayerWalkAnimation( mapper.player, dx, dy );\n\n\t\t\t// Now check for regular collision (walls etc).\n\t\t\tif (\n\t\t\t\t!mapper.collision.isWalkable( newCol, newRow ) ||\n\t\t\t\tmapper.doCollision( loc.col, loc.row, newCol, newRow, dx, dy )\n\t\t\t) {\n\t\t\t\tnewCol = loc.col;\n\t\t\t\tnewRow = loc.row;\n\t\t\t}\n\n\t\t\tb8.ECS.setComponent( mapper.player, 'Direction', { dx, dy } );\n\t\t\tb8.ECS.setLoc( mapper.player, newCol, newRow );\n\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Render the game scene.\n\t *\n\t * @returns {void}\n\t */\n\trender: function() {\n\n\t\tb8.cls( 0 );\n\n\t\tb8.locate( mapper.CONFIG.mapOffsetX, mapper.CONFIG.mapOffsetY );\n\t\tmapper.drawScreen();\n\t\tmapper.render( mapper.CONFIG.mapOffsetX, mapper.CONFIG.mapOffsetY );\n\n\t\t// Draw UI background.\n\t\tb8.locate( 0, b8.CONFIG.SCREEN_ROWS - mapper.sceneGame.UI.length );\n\t\tb8.Tilemap.draw( mapper.sceneGame.UI );\n\n\t\t// Draw currency value.\n\t\tb8.locate( 2, b8.CONFIG.SCREEN_ROWS - 2 );\n\t\tb8.color( parseInt( mapper.settings.coinColor ) || 10, 0 );\n\t\tb8.printChar( parseInt( mapper.settings.coin ) || 266 );\n\n\t\tb8.color( 15, 0 );\n\t\tb8.print( ' ' + parseInt( b8.Inventory.getCount( 'coin' ) ).toString().padStart( 4, '0' ) );\n\n\t\t// Draw heart containers.\n\t\tconst health = b8.ECS.getComponent( mapper.player, 'Health' );\n\t\tconst max = health.max;\n\t\tconst hp = health.value;\n\n\t\tfor ( let i = 0; i < Math.floor( max / 2 ); i++ ) {\n\t\t\tconst x = 2 + i;\n\t\t\tconst y = b8.CONFIG.SCREEN_ROWS - 3;\n\t\t\tb8.locate( x, y );\n\t\t\tif ( hp >= ( i * 2 ) + 2 ) {\n\t\t\t\t// Full heart.\n\t\t\t\tb8.color( 8, 0 );\n\t\t\t\tb8.printChar( 415 );\n\t\t\t} else if ( hp === ( i * 2 ) + 1 ) {\n\t\t\t\t// Half heart.\n\t\t\t\tb8.color( 8, 0 );\n\t\t\t\tb8.printChar( 416 );\n\t\t\t} else {\n\t\t\t\t// Empty heart.\n\t\t\t\tb8.color( 6, 0 );\n\t\t\t\tb8.printChar( 417 );\n\t\t\t}\n\t\t}\n\n\t\t// Draw keys.\n\t\tconst keys = b8.Inventory.filter( /^key/ );\n\t\t// Loop through keys and draw them.\n\t\tkeys.forEach(\n\t\t\t( item, index ) => {\n\t\t\t\tconst color = parseInt( item.id.split( '-' )[ 1 ] ) || 15;\n\t\t\t\tb8.locate( 10 + index, b8.CONFIG.SCREEN_ROWS - 2 );\n\t\t\t\tb8.color( color, -1 );\n\t\t\t\tb8.printChar( 255 );\n\t\t\t}\n\t\t);\n\n\t\t// Draw actions.\n\t\t// -------------\n\t\tb8.color( 15, -1 );\n\n\t\t// A button.\n\t\tb8.locate( 11, b8.CONFIG.SCREEN_ROWS - 4 );\n\t\tb8.print( ' Hit' );\n\n\t\t// B button.\n\t\tb8.locate( 15, b8.CONFIG.SCREEN_ROWS - 4 );\n\t\tb8.print( mapper.helpers.capitalizeWords( ' ' + mapper.promptAhead( mapper.player ) ) );\n\n\t\treturn;\n\n\t},\n\n};\n// const menuBg = `mB6YGIUBBAAAoIUBBAAAoIUBBAAAoIUDBQQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUSDwQAoIUTDwQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIURAwQAoIURAwQAoIUBBAAAoJgYhREDBACghQEEAACghQEEAACghQEEAACghRgpCgQAoIUBBAAAoIUBBAAAoIUSDwQAoIUBDwQAoIUBDwQAoIUABA8AoIUBDwQAoIUTDwQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUDBQQAoIUBBAAAoIURAwQAoIURAwQAoIUBBAAAoJgYhREDBACghQEEAACghQEEAACghQEEAACghQEKDQCghQEEAACghQAKBACghRgkDwQAoIUYcgQKAKCFGD0ECgCghRigBA8AoIUYPQQKAKCFCwQPAKCFAQoNAKCFAQQAAKCFEg0EAKCFAg0MAKCFEw0EAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCYGIUBBAAAoIUBBAAAoIURAwQAoIURAwQAoIUBCg0AoIUWCgQAoIUABAoAoIUBBAAAoIUYTgQKAKCFGD0ECgCghQMFBACghRgoBAoAoIUBCg0AoIUBCg0AoIUBBAAAoIUACg0AoIUYKQQNAKCFAAoNAKCFGBkNBACghRgZDQQAoIUYGQ0EAKCFGBkNBACghQEEAACghQEEAACgmBiFAQQAAKCFAQQAAKCFEQMEAKCFEQMEAKCFAQoNAKCFAgoJAKCFAQQAAKCFAQQAAKCFGE4ECgCghQEEDQCghQEEAACghQEEAACghQEEAACghQEKDQCghQEEAACghQAKDQCghRgqBA0AoIUACg0AoIUABA0AoIUABA0AoIUABA0AoIUYJQ0EAKCFAQQAAKCFAQQAAKCYGIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBCg0AoIUYKAQKAKCFGGEECgCghQEEAACghRhOBAoAoIUBCg0AoIUACgQAoIUBCg0AoIUBCg0AoIUWBAoAoIUBBAAAoIUYJA0EAKCFGGEFDQCghRglDQQAoIUBBA0AoIUABA0AoIUYgQ0EAKCFAQQAAKCFAwUEAKCFAQQAAKCYGIUBBAAAoIUDBQQAoIUBBAAAoIUBBAAAoIUYKgoEAKCFAQQAAKCFGCkKBACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACgmBiFGDUNBACghRgyDQQAoIUBBAAAoIUBBAAAoIUSDwQAoIURBA8AoIUYTgQKAKCFEQQPAKCFEw8EAKCFAQQAAKCFGE4ECgCghQEEAACghQEKBACghQEEAACghQEKBACghQEKBACghQEEAACghRYKBACghRhQBAoAoIUACgQAoIUABAoAoIUCCgkAoIUCCgkAoIUBBAAAoJgYhRgiBA0AoIUYIQQNAKCFAQQAAKCFEg8EAKCFAQ8EAKCFAQ8EAKCFGE4ECgCghRYKDwCghRhQBAoAoIUTDwQAoIUYTgQKAKCFGBoKBACghQIKCQCghQEEAACghQEKBACghRg9BAoAoIUBBAAAoIUBCgQAoIUYcwQKAKCFAQQKAKCFAQQAAKCFGFAECgCghQEEAACghRIPBACgmBiFAAANAKCFEAwNAKCFGDINBACghRgkDwQAoIUBDwQAoIUYoAQPAKCFGE4ECgCghRhQBAoAoIULBA8AoIULBA8AoIUYTgQKAKCFAgoJAKCFAgoJAKCFAwUEAKCFAQoEAKCFAQQAAKCFAQQAAKCFAQQKAKCFGFAECgCghQEECgCghRIPBACghRhQBAoAoIUBDw0AoIUBDw0AoJgYhQMFDQCghQAADQCghRghBA0AoIUBBAAAoIUBBAAAoIUBBAAAoIUYTgQKAKCFGCgECgCghRhQBAoAoIUBBAAAoIUYTgQKAKCFGBoECgCghQEKBACghQEEAACghQEKBACghQEKBACghQEEAACghQEKBACghRhQBAoAoIUSDwQAoIUYoAQPAKCFGFAECgCghQsEDwCghQsEDwCgmBiFAAANAKCFAwUNAKCFGDIBDQCghQAABACghQAABACghQEEAACghRgqCgQAoIUBBAAAoIUBBAAAoIUBBAAAoIUACgQAoIUBBAAAoIUACgQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUXDwQAoIUBDw0AoIUYoAQPAKCFGLMEDwCghRigBA8AoIULBA8AoIULBA8AoJgYhREBDQCghRgyAQ0AoIUAAA0AoIUYMg0EAKCFAAAEAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAwUEAKCFAQQAAKCFAQQAAKCFAQQAAKCFEQMEAKCFEQMEAKCFEQMEAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCYGIUDBQ0AoIUAAA0AoIUAAA0AoIUYIQQNAKCFAAAEAKCFAQQAAKCFEQMEAKCFEQMEAKCFEQMEAKCFAAMEAKCFAAAEAKCFAAAEAKCFEQMEAKCFAAAEAKCFAAAEAKCFAAAEAKCFEQMEAKCFEQMEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAQQAAKCYGIUDBQ0AoIUBDQQAoIUJDQUAoIUYMgENAKCFAAAEAKCFAAAEAKCFEQMEAKCFEQMEAKCFEQMEAKCFAQQAAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFGEsHBACghRhLBwQAoIUAAAQAoIUDBQQAoIURAwQAoJgYhQAADQCghQAADQCghQAADQCghQAADQCghRgyDQQAoIUAAAQAoIUBBAAAoIUBBAAAoIUBBAAAoIUACAQAoIUYNAgEAKCFAAAEAKCFGHcDBACghQAABACghQAABACghQAABACghQAABACghQAABACghQAABACghRkBTQIFAKCFGQFNAgUAoIUYMwgEAKCFAAAEAKCFEQMEAKCYGIURAQ0AoIUQDA0AoIUAAA0AoIUYMgENAKCFGCEEDQCghQMFBACghRg1BQQAoIUYMgUEAKCFAQQAAKCFAAgEAKCFGBkHCACghRgZBwgAoIUYGQcIAKCFGBkHCACghRgZBwgAoIUYGQcIAKCFGBkHCACghRgZBwgAoIUYGQcIAKCFGQFOAgUAoIUZAU0CBQCghRgZBwgAoIUACAQAoIUYNQUEAKCYGIUDBQ0AoIUDBQ0AoIUAAA0AoIUQDA0AoIUYIQQNAKCFAAAEAKCFGCIEBQCghRghBAUAoIUBBAAAoIUDBQQAoIURBwgAoIURBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBTQIFAKCFGQFNAgUAoIUZAQgHCACghRgyBQQAoIUYIgQFAKCYGIUAAA0AoIUAAA0AoIUAAA0AoIUAAA0AoIUAAA0AoIUYLAQFAKCFAAIFAKCFGCkBBQCghRgyBQQAoIUYGgEEAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIURBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAgHAKCFGQEICAcAoIUZAQgHCACghQACBQCghRgaAQUAoJgYhQMFDQCghQMFDQCghQAADQCghQAADQCghRAMDQCghRgoDQUAoIUYNQEFAKCFAAIBAKCFGCwFAQCghQACAQCghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghREHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUYNQEFAKCFAAIBAKCYGIURAQ0AoIUDBQ0AoIUAAA0AoIUYMgENAKCFEAwNAKCFAAANAKCFAAIBAKCFAAIBAKCFAAIBAKCFGFkFAQCghRkBTQUBAKCFGQFNBQEAoIUZAU0FAQCghRkBTgUBAKCFGQFPBQEAoIUZAU0FAQCghRkBTQUBAKCFGQFNBQEAoIUZAU0FAQCghRkBTgUBAKCFGQFNBQEAoIUZAU0FAQCghRhXBQEAoIUAAgEAoJgYhQMFDQCghQAADQCghQMFDQCghQAADQCghQAADQCghRgyAQ0AoIUYMg0BAKCFAAIBAKCFAAIBAKCFGFkCAQCghRkBTQIFAKCFGQFOAgUAoIUZAU0CBQCghRkBTQIFAKCFGHIBDQCghRg9AQ0AoIUYPQENAKCFGHMBDQCghRkBTQIFAKCFGQFNAgUAoIUZAU0CBQCghRkBTgIFAKCFGFcCAQCghQACAQCgmBiFEQENAKCFAwUNAKCFAAANAKCFAAANAKCFCQ0FAKCFAAANAKCFGCEBDQCghQACAQCghQACAQCghRhZAgEAoIUZAU0CBQCghQEABQCghRkBTQIFAKCFGQFNAgUAoIUYTgENAKCFAQAFAKCFAQANAKCFGFAFDQCghRkBTQIFAKCFAQAFAKCFAQAEAKCFGQFNAgUAoIUYVwIBAKCFAAIBAKCYGIUAAA0AoIUAAA0AoIUAAA0AoIUDBQ0AoIUAAA0AoIUYMgENAKCFAAANAKCFGQEgDA0AoIUZATIMDQCghRkBMgwNAKCFGQFNAgUAoIUYKwABAKCFGQFNAgUAoIUZAU0CBQCghRhOAQ0AoIUYKwABAKCFAQEFAKCFGFAFDQCghRkBTQIFAKCFGCsAAQCghQEBAQCghRkBTQIFAKCFGQEgDA0AoIUZASEMDQCgmBiFGDIGDQCghQMFDQCghRgyBg0AoIUYNAwNAKCFGDQMDQCghQAADQCghRgyDQwAoIUZATMNDACghRENDACghRENDACghRkBTQIFAKCFGBkCAwCghRkBTQIFAKCFGQFOAgUAoIUYTgENAKCFGD0MDQCghRg9DA0AoIUYUAUNAKCFGQFNAgUAoIUYGQIDAKCFGDcDDwCghRg3Aw8AoIUYNwMPAKCFEQ0MAKCYGIULBgcAoIULBgcAoIUOBgcAoIUYVwcMAKCFAAAMAKCFGQEgDQwAoIUZASUNDACghQAADACghRkBJQ0MAKCFGFMCDACghRkBTgIFAKCFGQFNAgUAoIUZAU8CBQCghRkBTQIFAKCFGIQFDQCghQsNBQCghRhhBQ0AoIUYhQUNAKCFGQFNAgUAoIUZAU0CBQCghRg3Aw8AoIUYNwMPAKCFGDcDDwCghRkBNw0MAKCYGIURBgcAoIUY5QYHAKCFGQEaBgcAoIUYVwcMAKCFAQwAAKCFEQ0MAKCFAQwAAKCFGQElDQwAoIUBDAAAoIUYUw0MAKCFAQ0MAKCFGQEyDA0AoIUBDQwAoIUZATcMDQCghQENDACghQENDACghRkBMgwNAKCFAQ0MAKCFGQEzDA0AoIUBDQwAoIUBDQwAoIUYPQUPAKCFAQwAAKCFGQElDQwAoJgYhRiUBw0AoIUYlAcNAKCFGJQHDQCghRgoDQwAoIUZASUNDACghQEMAACghRkBJQ0MAKCFGQElDQwAoIURDQwAoIUYVg0MAKCFGQE3DA0AoIUZATMMDQCghQENDACghRcFDQCghQEFDACghRglBQ0AoIUBDQwAoIUZATIMDQCghRkBNwwNAKCFAQ0MAKCFGQEzDA0AoIUBDQwAoIUZATUNDACghRENDACgmBiFAwENAKCFGQEzDA0AoIUZASUMDQCghRkBNwwNAKCFGCgNDACghRkBJQ0MAKCFAQwAAKCFGQEgDQwAoIUZATcNDACghRkBJQ0MAKCFAw0MAKCFAw0MAKCFGQElDQwAoIUDDQwAoIUZATcNDACghRcCDACghQMNAgCghRMCDACghRkBMw0MAKCFGFYNDACghRkBNwwNAKCFGQEyDA0AoIUZATMMDQCghRkBJQ0MAKCYGIUYWAwNAKCFGQElDA0AoIUZASUMDQCghQAMDQCghRkBMwwNAKCFGQEzDA0AoIUZATcMDQCghRgoDQwAoIUZASUNDACghQEMAACghRkBNw0MAKCFAQwAAKCFGQEzDQwAoIUZATcNDACghRICDACghRgYAgwAoIUZATMNDACghRkBJQ0MAKCFAQwAAKCFGQElDQwAoIUZASUNDACghRkBJQ0MAKCFGQElDQwAoIUZASUNDACg`;\n\nmapper.sceneMenu = {\n\n\t/**\n\t * Initialize the menu scene.\n\t *\n\t * @returns {void}\n\t */\n\tinit: function() {\n\n\t\t// No splash screen so skip the menu.\n\t\tif ( !mapper.menu.hasSplash() ) {\n\t\t\tb8.Scene.set( 'game' );\n\t\t\treturn;\n\t\t}\n\n\t\tmapper.sceneMenu.main();\n\n\t},\n\n\n\t/**\n\t * Draw the main menu.\n\t *\n\t * @returns {void}\n\t */\n\tmain: async () => {\n\n\t\tb8.locate( 0, 0 );\n\t\tmapper.menu.drawSplash();\n\n\t\tb8.locate( 5, 18 );\n\t\tb8.color( 0, 10 );\n\n\t\tlet menuChoices = [ \"Start Game\", ];\n\t\tif ( mapper.menu.hasInstructions() ) menuChoices.push( \"Instructions\" );\n\t\tif ( mapper.menu.hasCredits() ) menuChoices.push( \"Credits\" );\n\n\t\tlet choice = await b8.Async.menu(\n\t\t\tmenuChoices,\n\t\t\t{\n\t\t\t\tborder: false,\n\t\t\t\tpadding: 0,\n\t\t\t\tcenterH: true,\n\t\t\t}\n\t\t);\n\n\t\tconst selected = menuChoices[ choice ];\n\n\t\t// Start a new game.\n\t\tif ( 'Start Game' === selected ) {\n\t\t\tb8.Scene.set( 'game' );\n\t\t\treturn;\n\t\t}\n\n\t\t// Show instructions.\n\t\tif ( 'Instructions' === selected ) {\n\t\t\tb8.locate( 2, 2 );\n\t\t\tb8.color( 15, 13 );\n\t\t\tconst instructions = b8.wrapText(\n\t\t\t\tmapper.menu.getInstructions(),\n\t\t\t\tb8.CONFIG.SCREEN_COLS - 6\n\t\t\t);\n\t\t\tawait b8.Async.dialog( instructions, [ \"OK\" ] );\n\t\t}\n\n\t\t// Show credits.\n\t\tif ( 'Credits' === selected ) {\n\t\t\tb8.locate( 2, 2 );\n\t\t\tb8.color( 15, 13 );\n\t\t\tconst credits = b8.wrapText(\n\t\t\t\tmapper.menu.getCredits(),\n\t\t\t\tb8.CONFIG.SCREEN_COLS - 6\n\t\t\t);\n\t\t\tawait b8.Async.dialog( credits, [ \"OK\" ] );\n\t\t}\n\n\t\tsetTimeout( mapper.sceneMenu.main, 10 );\n\n\t}\n\n};\n\nmapper.systems.bumpAttack = function( dt ) {\n\n\tconst ids = b8.ECS.query( 'BumpAttack' );\n\n\tfor ( const id of ids ) {\n\n\t\tconst bump = b8.ECS.getComponent( id, 'BumpAttack' );\n\t\tconst targetId = bump.targetId;\n\n\t\tif ( !b8.ECS.hasComponent( targetId, 'Health' ) ) {\n\t\t\t// Target has no health, remove BumpAttack component.\n\t\t\tb8.ECS.removeComponent( id, 'BumpAttack' );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst targetHealth = b8.ECS.getComponent( targetId, 'Health' );\n\n\t\t// Simple attack logic: reduce target health by attacker's attack value.\n\t\tconst attackerAttack = b8.ECS.getComponent( id, 'Attack' ) || { value: 1 };\n\t\ttargetHealth.value -= attackerAttack.value;\n\n\t\t// Check if target is defeated.\n\t\tif ( targetHealth.value <= 0 ) {\n\t\t\tb8.ECS.removeEntity( targetId );\n\t\t}\n\n\t\t// Remove BumpAttack component after processing.\n\t\tb8.ECS.removeComponent( id, 'BumpAttack' );\n\n\t}\n\n};\n\n\nmapper.systems.characterAnimation = function( dt ) {\n\n\tconst anims = b8.ECS.query( 'CharacterAnimation' );\n\tif ( !anims ) return;\n\n\t// Loop through anims.\n\tfor ( const id of anims ) {\n\n\t\tconst anim = b8.ECS.getComponent( id, 'CharacterAnimation' );\n\t\tif ( !anim ) continue;\n\n\t\tif ( anim.duration > 0 ) {\n\n\t\t\tanim.duration -= dt;\n\t\t\tif ( anim.duration <= 0 ) {\n\n\t\t\t\tlet defaultAnimation = anim.default || '';\n\t\t\t\tconst direction = b8.ECS.getComponent( id, 'Direction' );\n\n\t\t\t\tif ( direction ) {\n\t\t\t\t\tconst directionNames = {\n\t\t\t\t\t\t'0,1': '',\n\t\t\t\t\t\t'0,-1': '-up',\n\t\t\t\t\t\t'1,0': '-right',\n\t\t\t\t\t\t'-1,0': '-left'\n\t\t\t\t\t};\n\t\t\t\t\tconst directionName = directionNames[ `${direction.dx},${direction.dy}` ] || '';\n\t\t\t\t\tdefaultAnimation = defaultAnimation + directionName;\n\t\t\t\t}\n\n\t\t\t\tanim.name = defaultAnimation;\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\n/**\n * Path Follower System\n *\n * Moves entities along predefined paths based on their PathFollower component.\n */\nmapper.systems.pathFollower = async function( dt ) {\n\n\tconst animationMap = {\n\t\t'U': 'move-up',\n\t\t'D': 'move-down',\n\t\t'L': 'move-left',\n\t\t'R': 'move-right',\n\t\t'FU': 'idle-up',\n\t\t'FD': 'idle-down',\n\t\t'FL': 'idle-left',\n\t\t'FR': 'idle-right',\n\t};\n\n\tconst animationInverse = {\n\t\t'U': 'D',\n\t\t'D': 'U',\n\t\t'L': 'R',\n\t\t'R': 'L',\n\t\t'FU': 'FD',\n\t\t'FD': 'FU',\n\t\t'FL': 'FR',\n\t\t'FR': 'FL',\n\t};\n\n\tconst ids = b8.ECS.query( 'Loc', 'PathFollower' );\n\n\tfor ( const id of ids ) {\n\n\t\tconst pf = b8.ECS.getComponent( id, 'PathFollower' );\n\n\t\t// Skip if no steps defined.\n\t\tif ( !pf ) continue;\n\t\tif ( !pf.steps.length ) continue;\n\n\t\t// Update timer.\n\t\tpf.timer -= dt;\n\n\t\tif ( pf.timer > 0 ) continue;\n\t\tpf.timer = mapper.CONFIG.moveDelay * 2;\n\n\t\tconst step = pf.steps[ pf.index ];\n\n\t\tlet canMove = false;\n\n\t\t// Face command - always allowed.\n\t\tif ( step.dir && step.dir[ 0 ] === 'F' ) canMove = true;\n\n\t\t// Check if step is not blocked by collision.\n\t\tif (\n\t\t\tmapper.collision.isWalkable( step.x, step.y ) &&\n\t\t\t!mapper.collision.isSolidAt( step.x, step.y )\n\t\t) { canMove = true; }\n\n\t\t// If movement is blocked, skip to next character.\n\t\tif ( !canMove ) continue;\n\n\t\t// Move to next step\n\t\tb8.ECS.setLoc( id, step.x, step.y );\n\n\t\t// Advance to next step index based on mode\n\t\t_advancePathIndex( pf );\n\n\t\t// Update animation based on direction\n\t\tconst anim = b8.ECS.getComponent( id, 'CharacterAnimation' );\n\t\tanim.duration = 0.5;\n\t\tif ( animationMap[ step.dir ] ) {\n\t\t\tlet direction = step.dir;\n\t\t\t// Invert the direction for reverse movement.\n\t\t\tif ( pf.dirStep === -1 ) { direction = animationInverse[ step.dir ] || step.dir; }\n\t\t\tanim.name = animationMap[ direction ];\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Advance the path index based on the PathFollower mode.\n\t *\n\t * @param {object} pf - The PathFollower component.\n\t * @returns {void}\n\t */\n\tfunction _advancePathIndex( pf ) {\n\n\t\tconst last = pf.steps.length - 1;\n\n\t\tswitch ( pf.mode ) {\n\n\t\t\t// Advance index until the last step, then stop.\n\t\t\tcase 'once':\n\n\t\t\t\tif ( pf.index < last ) pf.index++;\n\t\t\t\tbreak;\n\n\t\t\t// Advance index and loop back to start after last step.\n\t\t\tcase 'loop':\n\n\t\t\t\tpf.index = ( pf.index + 1 ) % pf.steps.length;\n\t\t\t\tbreak;\n\n\t\t\t// Advance index back and forth between first and last step.\n\t\t\tcase 'pingpong':\n\t\t\tdefault:\n\n\t\t\t\tif ( pf.index === 0 ) {\n\t\t\t\t\tpf.dirStep = 1;\n\t\t\t\t} else if ( pf.index === last ) {\n\t\t\t\t\tpf.dirStep = -1;\n\t\t\t\t}\n\n\t\t\t\tpf.index += pf.dirStep;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n};\n\n\n\n/**\n * Mapper system: Pickups\n *\n * Handles player picking up items in the game world.\n */\nmapper.systems.pickup = function() {\n\n\tconst playerId = mapper.player;\n\tconst pLoc = b8.ECS.getComponent( playerId, 'Loc' );\n\n\t// Get all pickup entities.\n\tconst pickupIds = b8.ECS.query( 'Pickup', 'Loc' );\n\n\t// Process each pickup and check their location.\n\tpickupIds.forEach(\n\t\t( id ) => {\n\n\t\t\t// Check if at same location as player.\n\t\t\tconst loc = b8.ECS.getComponent( id, 'Loc' );\n\t\t\tif ( loc.col !== pLoc.col || loc.row !== pLoc.row ) return;\n\n\t\t\t// Handle the pickup.\n\t\t\tconst pickup = b8.ECS.getComponent( id, 'Pickup' );\n\n\t\t\tmapper.giveRewards(\n\t\t\t\tplayerId,\n\t\t\t\t[ { type: pickup.type, props: pickup.props } ]\n\t\t\t);\n\n\t\t\t// Consume (remove from world).\n\t\t\tif ( pickup.consume ) {\n\n\t\t\t\t// Remove entity.\n\t\t\t\tb8.ECS.removeEntity( id );\n\n\t\t\t\t// Remove map object.\n\t\t\t\tmapper.removeObjectAt( loc.col, loc.row, pickup.type );\n\n\t\t\t}\n\n\t\t}\n\t);\n\n};\n\n/**\n * Portal system\n *\n */\n\n/**\n * Check for portal at given location.\n * If found, handle teleportation.\n *\n * @param {number} col - The column to check.\n * @param {number} row - The row to check.\n * @returns {Promise<boolean>} True if portal handled, false otherwise.\n */\nmapper.systems.tryPortal = async function( col, row ) {\n\n\tconst id = b8.ECS.entitiesAt( col, row );\n\n\tif ( !id ) return false;\n\n\tfor ( const entityId of id ) {\n\t\tconst portal = b8.ECS.getComponent( entityId, 'Portal' );\n\t\treturn mapper.systems.handlePortal( portal );\n\t}\n\n\treturn false;\n\n}\n\n\n/**\n * Handle portal teleportation.\n *\n * @param {Object} portal - The portal component.\n * @returns {Promise<boolean>} True if portal handled, false otherwise.\n */\nmapper.systems.handlePortal = async function( portal ) {\n\n\tif ( !portal ) return false;\n\tif ( '' === portal.target ) return false;\n\n\t// Find portal with the matching name.\n\n\tconst doorways = mapper.helpers.getObjectsByType( 'door' );\n\tconst targetDoorway = doorways.find(\n\t\t( door ) => {\n\t\t\treturn door.props.name === portal.target;\n\t\t}\n\t);\n\n\t// Teleport player to target doorway.\n\tif ( targetDoorway ) {\n\t\tawait b8.Async.wait( 0.1 );\n\t\tmapper.setCurrentMap( targetDoorway.mapId );\n\t\tb8.ECS.setLoc( mapper.player, targetDoorway.x, targetDoorway.y );\n\t}\n\n\treturn false; // Allow stepping onto the portal\n\n};\n\n\nmapper.systems.tryPushing = ( col, row, dx, dy ) => {\n\n\tconst hitX = col + dx;\n\tconst hitY = row + dy;\n\n\tfor ( const id of b8.ECS.entitiesAt( hitX, hitY ) ) {\n\n\t\t// If not a solid object, or pushable, skip.\n\t\tif ( !b8.ECS.hasComponent( id, 'Solid' ) ) continue;\n\t\tif ( !b8.ECS.hasComponent( id, 'Pushable' ) ) continue;\n\n\t\tconst loc = b8.ECS.getComponent( id, 'Loc' );\n\t\tconst newCol = loc.col + dx;\n\t\tconst newRow = loc.row + dy;\n\n\t\tconst blocked =\n\t\t\t!mapper.collision.isWalkable( newCol, newRow ) ||\n\t\t\tb8.ECS.entitiesAt( newCol, newRow ).some( e => b8.ECS.hasComponent( e, 'Solid' ) );\n\n\t\tif ( !blocked ) {\n\t\t\t// move the pushable thing.\n\t\t\tb8.ECS.setLoc( id, newCol, newRow );\n\n\t\t\tb8.Sfx.play( 'fx/action/drag' );\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\treturn false;\n\n};\n\n\n\nmapper.systems.tryPulling = ( col, row, dx, dy, playerId ) => {\n\n\tconst hitCol = col + dx;\n\tconst hitRow = row + dy;\n\n\tfor ( const id of b8.ECS.entitiesAt( hitCol, hitRow ) ) {\n\n\t\tif ( !b8.ECS.hasComponent( id, 'Solid' ) ) continue;\n\t\tif ( !b8.ECS.hasComponent( id, 'Pushable' ) ) continue; // now covers pull\n\n\t\tconst backCol = col - dx;\n\t\tconst backRow = row - dy;\n\t\tif ( !mapper.collision.isWalkable( backCol, backRow ) ||\n\t\t\tb8.ECS.entitiesAt( backCol, backRow ).some( e => b8.ECS.hasComponent( e, 'Solid' ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Move target into player's tile, move player back\n\t\tb8.ECS.setLoc( id, col, row );\n\t\tb8.ECS.setLoc( playerId, backCol, backRow );\n\n\t\tmapper.setPlayerWalkAnimation( playerId, dx, dy );\n\n\t\tb8.Sfx.play( 'fx/action/drag' );\n\n\t\treturn true;\n\n\t}\n\n\treturn false;\n\n};\n\n\nmapper.systems.sprite = function( dt ) {\n\n\tconst ids = b8.ECS.query( 'Sprite' );\n\n\tfor ( const id of ids ) {\n\n\t\tconst spr = b8.ECS.getComponent( id, 'Sprite' );\n\n\t\tif ( spr.nudgeCol ) { spr.nudgeCol = spr.nudgeCol * 0.75; }\n\t\tif ( spr.nudgeRow ) { spr.nudgeRow = spr.nudgeRow * 0.75; }\n\n\t}\n\n};\nmapper.systems.teleportSystem = async function( dt ) {\n\n\tconst list = b8.ECS.query( 'Teleport' );\n\n\tfor ( const [ id, teleport ] of list ) {\n\n\t\tconst doorways = b8.ECS.query( 'Portal' );\n\n\t\tconst targetDoorway = doorways.find(\n\t\t\t( [ targetId ] ) => {\n\t\t\t\tconst targetPortal = b8.ECS.getComponent( targetId, 'Portal' );\n\t\t\t\treturn targetPortal?.name === teleport.target;\n\t\t\t}\n\t\t);\n\n\t\tif ( targetDoorway ) {\n\t\t\tconst targetLoc = b8.ECS.getComponent( targetDoorway[ 0 ], 'Loc' );\n\t\t\tif ( targetLoc ) {\n\t\t\t\tawait b8.Async.wait( 0.1 );\n\t\t\t\tb8.ECS.setLoc( id, targetLoc.col, targetLoc.row );\n\t\t\t}\n\t\t}\n\n\t\t// Remove teleport after executing\n\t\tb8.ECS.removeComponent( id, 'Teleport' );\n\n\t}\n\n}\n\n\nmapper.systems.vfx = async function( dt ) {\n\n\tconst list = b8.ECS.query( 'Vfx', 'Sprite' );\n\n\tfor ( const id of list ) {\n\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\n\t\tconst animation = b8.Vfx.get( sprite.id );\n\n\t\tif ( animation ) {\n\t\t\tif ( b8.Animation.shouldLoop( animation, sprite.startTime ) ) continue;\n\t\t}\n\n\t\tb8.ECS.removeEntity( id );\n\n\t}\n\n}\n\nmapper.types.skeleton = {\n\n\n\n};\n\nmapper.types.chestOpen = {\n\n\tspawn: function( col, row, props ) {\n\n\t\tconst entitySettings = {\n\t\t\tType: { name: 'chest' },\n\t\t\tLoc: { col, row },\n\t\t\tSprite: {\n\t\t\t\ttile: 271,\n\t\t\t\tfg: props.fg || 15,\n\t\t\t\tbg: props.bg || 0,\n\t\t\t\tdepth: 10\n\t\t\t},\n\t\t\tSolid: {},\n\t\t};\n\n\t\tconsole.log( 'chest open props', props );\n\n\t\tif ( props.message ) {\n\t\t\tentitySettings.Message = { message: props.message };\n\t\t\tentitySettings.Action = { verb: 'read' };\n\t\t}\n\n\t\treturn b8.ECS.create( entitySettings );\n\n\t},\n\n};\nmapper.types.chest = {\n\n\titems: {\n\t\t0: 'Empty',\n\t\t1: 'Key',\n\t\t2: 'Coin',\n\t\t3: '10 Coins',\n\t\t4: '50 Coins',\n\t\t5: 'Half Heart',\n\t\t6: 'Heart',\n\t\t7: 'Full Heart',\n\t\t// 4: '1 Bomb',\n\t\t// 5: '5 Bombs',\n\t},\n\n\n\tspawn: function( col, row, props ) {\n\n\t\tlet items = [];\n\t\tlet foregroundColor = props.fg || 15;\n\t\tlet containsType = '';\n\n\t\tif ( mapper.types.chest.items[ props.contains ] ) {\n\t\t\tcontainsType = mapper.types.chest.items[ props.contains ];\n\t\t}\n\n\t\tif ( containsType === 'Key' ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'key',\n\t\t\t\t\tprops: { name: `key-${foregroundColor}` },\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif ( containsType.endsWith( 'Coins' ) ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'coin',\n\t\t\t\t\tprops: { amount: parseInt( containsType.split( ' ' )[ 0 ], 10 ) }\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif ( containsType === 'Coin' ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'coin',\n\t\t\t\t\tprops: { amount: 1 }\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif ( containsType === 'Half Heart' ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'health',\n\t\t\t\t\tprops: { amount: 1 }\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif ( containsType === 'Heart' ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'health',\n\t\t\t\t\tprops: { amount: 2 }\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif ( containsType === 'Full Heart' ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'health',\n\t\t\t\t\tprops: { amount: 9999 }\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'chest' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 253,\n\t\t\t\t\tfg: foregroundColor,\n\t\t\t\t\tbg: props.bg || 0,\n\t\t\t\t\tdepth: 10\n\t\t\t\t},\n\t\t\t\tSolid: {},\n\t\t\t\tOpenable: {\n\t\t\t\t\tclosedTile: 253,\n\t\t\t\t\topenedTile: 271,\n\t\t\t\t\tnewType: 'chestOpen',\n\t\t\t\t},\n\t\t\t\tMessage: { message: props.message || \"\" },\n\t\t\t\tReward: { items },\n\t\t\t\tAction: {\n\t\t\t\t\tverb: 'open'\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n};\nmapper.types.coin = {\n\n\t/**\n\t * Spawn a coin entity.\n\t *\n\t * @param {number} col - The column to spawn the coin at.\n\t * @param {number} row - The row to spawn the coin at.\n\t * @param {Object} props - Additional properties for the coin.\n\t * @returns {number} The entity ID of the spawned coin.\n\t */\n\tspawn: function( col, row, props ) {\n\n\t\treturn mapper.types.pickup.spawn(\n\t\t\tcol,\n\t\t\trow,\n\t\t\t{\n\t\t\t\ttype: 'coin',\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: parseInt( mapper.settings.coin ) || 266,\n\t\t\t\t\tfg: mapper.settings.coinColor || 14,\n\t\t\t\t\tbg: props.bg || 0\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Handle the player picking up the coin.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @param {Object} pickup - The Pickup component of the coin.\n\t * @returns {void}\n\t */\n\tpickupHandler: function( playerId, pickup ) {\n\n\t\tb8.Inventory.add( 'coin', pickup?.props?.amount || 1 );\n\t\tb8.Sfx.play( 'game/coin/002' );\n\n\t},\n\n};\n\nmapper.types.crate = {\n\n\tspawn: function( col, row, props ) {\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'crate' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 352,\n\t\t\t\t\tfg: props.fg || 15,\n\t\t\t\t\tbg: props.bg || 0,\n\t\t\t\t\tdepth: 10\n\t\t\t\t},\n\t\t\t\tSolid: {},\n\t\t\t\tPushable: {},\n\t\t\t\tAction: { verb: 'pull' },\n\t\t\t}\n\t\t);\n\n\t},\n\n};\n\nmapper.types.doorOpen = {\n\n\tspawn: function( col, row, props ) {\n\n\t\tconst doorProps = {\n\t\t\tType: { name: 'door' },\n\t\t\tLoc: { col, row },\n\t\t\tSprite: {\n\t\t\t\ttile: 216,\n\t\t\t\tfg: props.fg || 14,\n\t\t\t\tbg: props.bg || 0\n\t\t\t},\n\t\t\tPortal: {\n\t\t\t\tname: props.name || null,\n\t\t\t\ttarget: props.leadsTo || ''\n\t\t\t},\n\t\t};\n\n\t\treturn b8.ECS.create( doorProps );\n\n\t},\n\n\n\tonCharacterCollision: function( id, newCol, newRow, dx, dy ) {\n\n\t\t// Check if the player is trying to step onto a portal.\n\t\tmapper.systems.tryPortal( newCol, newRow );\n\t\treturn false;\n\n\t},\n\n};\n\nmapper.types.doorStairs = {\n\n\tspawn: function( col, row, props ) {\n\n\t\tconst icon = props.icon || 197;\n\n\t\tconst stairsProps = {\n\t\t\tType: { name: 'doorStairs' },\n\t\t\tLoc: { col, row },\n\t\t\tSprite: {\n\t\t\t\ttile: icon,\n\t\t\t\tfg: props.fg || 14,\n\t\t\t\tbg: props.bg || 0\n\t\t\t},\n\t\t\tPortal: {\n\t\t\t\tname: props.name || null,\n\t\t\t\ttarget: props.leadsTo || ''\n\t\t\t},\n\t\t};\n\n\t\treturn b8.ECS.create( stairsProps );\n\n\t},\n\n\n\tonCharacterCollision: function( id, newCol, newRow, dx, dy ) {\n\n\t\t// Check if the player is trying to step onto a portal.\n\t\tmapper.systems.tryPortal( newCol, newRow );\n\t\treturn false;\n\n\t},\n\n};\n\nmapper.types.door = {\n\n\tTILE_DOOR_OPEN: 216,\n\tTILE_DOOR_DEFAULT: 219,\n\n\tspawn: function( col, row, props ) {\n\n\t\tconst icon = props.icon || mapper.types.door.TILE_DOOR_DEFAULT;\n\n\t\tconst doorProps = {\n\t\t\tType: { name: 'door' },\n\t\t\tLoc: { col, row },\n\t\t\tSprite: {\n\t\t\t\ttile: icon,\n\t\t\t\tfg: props.fg || 14,\n\t\t\t\tbg: props.bg || 0\n\t\t\t},\n\t\t\tPortal: {\n\t\t\t\tname: props.name || null,\n\t\t\t\ttarget: props.leadsTo || ''\n\t\t\t},\n\t\t};\n\n\t\tif ( icon !== mapper.types.door.TILE_DOOR_OPEN ) {\n\t\t\tdoorProps.Solid = {};\n\t\t}\n\n\t\treturn b8.ECS.create( doorProps );\n\n\t},\n\n\n\tonCharacterCollision: function( id, newCol, newRow, dx, dy ) {\n\n\t\t// If the door is open, allow passing through.\n\t\tif ( !b8.ECS.hasComponent( id, 'Solid' ) ) {\n\n\t\t\t// Check if the player is trying to step onto a portal.\n\t\t\tmapper.systems.tryPortal( newCol, newRow );\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\t\tconst keyName = `key-${sprite.fg ?? \"default\"}`;\n\n\t\tif ( b8.Inventory.has( keyName ) ) {\n\t\t\tb8.ECS.removeComponent( id, 'Solid' );\n\t\t\tsprite.tile = mapper.types.door.TILE_DOOR_OPEN;\n\t\t\tb8.Sfx.play( 'ui/click/004' );\n\t\t\treturn true;\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n};\n\nmapper.types.enemy = {\n\n\t// Properties [ health, attack, color ]\n\tdifficulties: {\n\t\t'Easy': [ 3, 1, 11 ],\n\t\t'Medium': [ 5, 2, 9 ],\n\t\t'Hard': [ 8, 3, 8 ],\n\t},\n\n\tspawn: function( col, row, props ) {\n\n\t\tconst initialDirection = 'D';\n\n\t\tconst difficulty = props.health || 'Easy';\n\t\tconst [ health, attack, color ] = mapper.types.enemy.difficulties[ difficulty ] || mapper.types.enemy.difficulties[ 'Easy' ];\n\n\t\t/**\n\t\t * Create enemy character entity.\n\t\t */\n\t\tconst characterProperties = {\n\t\t\tType: { name: 'enemy' },\n\t\t\tLoc: { col, row },\n\t\t\tSprite: {\n\t\t\t\ttype: 'actor',\n\t\t\t\ttile: parseInt( props.actor ) || 6,\n\t\t\t\tfg: color || 15,\n\t\t\t\tbg: 0,\n\t\t\t\tdepth: 50,\n\t\t\t},\n\t\t\tSolid: {},\n\t\t\tCharacterAnimation: {\n\t\t\t\tname: 'idle',\n\t\t\t\tdefault: 'idle',\n\t\t\t\tduration: 0,\n\t\t\t},\n\t\t\tAttackTarget: {},\n\t\t\tHealth: {\n\t\t\t\tvalue: health || 3,\n\t\t\t\tmax: health || 3\n\t\t\t},\n\t\t\tAttack: {\n\t\t\t\tvalue: attack || 1\n\t\t\t},\n\t\t};\n\n\t\t// Add PathFollower component if a path is defined\n\t\tif ( props.path && b8.Path.validPathSyntax( props.path ) ) {\n\n\t\t\tlet mode = props.mode || 'pingpong';\n\n\t\t\tconst steps = b8.Path.parseCode(\n\t\t\t\tprops.path,\n\t\t\t\tcol,                               // startCol\n\t\t\t\trow,                               // startRow\n\t\t\t\tinitialDirection                   // initialDir\n\t\t\t);\n\n\t\t\tconst lastStep = steps.length - 1;\n\t\t\tif ( steps[ lastStep ].x === col && steps[ lastStep ].y === row ) {\n\t\t\t\tmode = 'loop';\n\t\t\t}\n\n\t\t\tcharacterProperties.PathFollower = {\n\t\t\t\tsteps,\n\t\t\t\tindex: 0,\n\t\t\t\tmode,\n\t\t\t\tdirStep: 1,                     // for pingpong direction: 1 or -1\n\t\t\t\ttimer: 0,                       // accumulates dt\n\t\t\t\tstartDir: props.startDir || initialDirection,\n\t\t\t}\n\n\t\t};\n\n\t\treturn b8.ECS.create( characterProperties );\n\n\t},\n\n};\n\nmapper.types.healthFull = {\n\n\tspawn: function( col, row, props ) {\n\n\t\treturn mapper.types.pickup.spawn(\n\t\t\tcol,\n\t\t\trow,\n\t\t\t{\n\t\t\t\ttype: 'health',\n\t\t\t\t// Set this health pickup to a large amount,\n\t\t\t\t// It will fully heal the player.\n\t\t\t\t// The value will be capped at max health in the handler.\n\t\t\t\tprops: { amount: 1000 },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 414,\n\t\t\t\t\tfg: 10,\n\t\t\t\t\tbg: 0\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t// pickupHandler()\n\t// Handled by mapper.types.health.pickupHandler\n\n};\n\nmapper.types.healthHalf = {\n\n\tspawn: function( col, row, props ) {\n\n\t\treturn mapper.types.pickup.spawn(\n\t\t\tcol,\n\t\t\trow,\n\t\t\t{\n\t\t\t\ttype: 'health',\n\t\t\t\tprops: { amount: 1 },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 416,\n\t\t\t\t\tfg: 8,\n\t\t\t\t\tbg: 0\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t// pickupHandler()\n\t// Handled by mapper.types.health.pickupHandler\n\n};\n\nmapper.types.health = {\n\n\tspawn: function( col, row, props ) {\n\n\t\treturn mapper.types.pickup.spawn(\n\t\t\tcol,\n\t\t\trow,\n\t\t\t{\n\t\t\t\ttype: 'health',\n\t\t\t\tprops: { amount: 2 },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 415,\n\t\t\t\t\tfg: 8,\n\t\t\t\t\tbg: 0\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Handle the player picking up the health pickup.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @param {Object} pickup - The Pickup component of the health item.\n\t * @returns {void}\n\t */\n\tpickupHandler: function( playerId, pickup ) {\n\n\t\tconst health = b8.ECS.getComponent( playerId, 'Health' );\n\t\thealth.value = Math.min( health.max, health.value + ( pickup.props.amount || 1 ) );\n\n\t},\n\n\n};\n\nmapper.types.key = {\n\n\t/**\n\t * Spawn a key entity at the specified location.\n\t *\n\t * @param {number} col - The column to spawn the key at.\n\t * @param {number} row - The row to spawn the key at.\n\t * @param {Object} props - Additional properties for the key (e.g., fg, bg colors).\n\t * @returns {number} The entity ID of the spawned key.\n\t */\n\tspawn: function( col, row, props ) {\n\n\t\tconst color = props.fg || 14;\n\n\t\treturn mapper.types.pickup.spawn(\n\t\t\tcol,\n\t\t\trow,\n\t\t\t{\n\t\t\t\ttype: 'key',\n\t\t\t\tprops: { name: `key-${color}` },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 255,\n\t\t\t\t\tfg: props.fg || 14,\n\t\t\t\t\tbg: props.bg || 0\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Handle the player picking up the key.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @param {Object} pickup - The Pickup component of the key.\n\t * @returns {void}\n\t */\n\tpickupHandler: function( playerId, pickup ) {\n\n\t\tb8.Inventory.add( pickup.props.name );\n\t\tb8.Sfx.play( 'tone/bloop/006' );\n\n\t},\n\n};\n\nmapper.types.pickup = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tif ( !props.type ) return;\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'pickup' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: props.Sprite.tile ?? 415,\n\t\t\t\t\tfg: props.Sprite.fg ?? 8,\n\t\t\t\t\tbg: props.Sprite.bg ?? 0\n\t\t\t\t},\n\t\t\t\tPickup: {\n\t\t\t\t\t// 'health', 'coin', 'key', etc\n\t\t\t\t\ttype: props.type,\n\t\t\t\t\t// remove after pickup\n\t\t\t\t\tconsume: props.consume ?? true,\n\t\t\t\t\t// Custom attributes for handler function\n\t\t\t\t\tprops: props.props || {}\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n};\n\nmapper.types.signpost = {\n\n\tspawn: function( col, row, props ) {\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'signpost' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: props.icon || 252,\n\t\t\t\t\tfg: props.fg || 15,\n\t\t\t\t\tbg: props.bg || 0\n\t\t\t\t},\n\t\t\t\tSolid: {},\n\t\t\t\tMessage: { message: props.message || \"\" },\n\t\t\t\tAction: { verb: 'read' },\n\t\t\t}\n\t\t);\n\n\t},\n\n};\n\n\nmapper.types.start = {\n\n\tspawn: function( col, row, props ) {\n\n\t\tb8.ECS.setLoc( mapper.player, col, row );\n\n\t},\n\n};\n\nmapper.types.vfx = {\n\n\tspawn: function( col, row, props ) {\n\n\t\tif ( !props.id ) return {};\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'vfx' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tVfx: {},\n\t\t\t\tSprite: {\n\t\t\t\t\ttype: 'vfx',\n\t\t\t\t\tid: props.id,\n\t\t\t\t\tstartTime: b8.Core.getNow() + ( props.offsetTime || 0 ),\n\t\t\t\t\tfg: props.fg || 15,\n\t\t\t\t\tbg: props.bg || 0,\n\t\t\t\t\tdepth: 50,\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n};\n"],
  "mappings": "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",
  "names": ["offsetX", "offsetY"]
}
