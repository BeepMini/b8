{
  "version": 3,
  "sources": ["../plugin.mapper.js"],
  "sourcesContent": ["const mapper = {\n\n\t// All loaded maps.\n\tmaps: [],\n\n\t// Currently active map.\n\tcurrentMapId: null,\n\n\t// Map of entity types to their handlers.\n\ttypes: {},\n\tsystems: {},\n\tactions: {},\n\tsettings: {},\n\tbg: {},\n\tlastPosition: null,\n\n\t// The player entity ID.\n\tplayer: null,\n\n\n\t/**\n\t * Initialize and start the game with the provided map data.\n\t *\n\t * @param {Object} mapData - The map data object containing map layout, tiles, objects, and settings.\n\t * @returns {void}\n\t */\n\tplay: function( mapData ) {\n\n\t\tb8.Utilities.checkObject( 'mapData', mapData );\n\n\t\tmapper.mapData = mapData;\n\n\t\tmapper.reset();\n\n\t\tb8.Scene.add( 'menu', mapper.sceneMenu );\n\t\tb8.Scene.add( 'game', mapper.sceneGame );\n\t\tb8.Scene.add( 'gameover', mapper.sceneGameOver );\n\t\tb8.Scene.set( 'menu' );\n\t\t// b8.Scene.set( 'gameover' );\n\n\t},\n\n\n\t/**\n\t * Reset the game state to the initial map data.\n\t *\n\t * @returns {void}\n\t */\n\treset: function() {\n\n\t\tmapper.load( mapper.mapData );\n\n\t},\n\n\n\t/**\n\t * Continue the game from the last doorway.\n\t *\n\t * @returns {void}\n\t */\n\tcontinue: function() {\n\n\t\tb8.ECS.setComponent(\n\t\t\tmapper.player,\n\t\t\t'Health',\n\t\t\t{\n\t\t\t\tvalue: 6,\n\t\t\t\tmax: 12\n\t\t\t}\n\t\t);\n\n\t\t// Set map and force reload of map to reset properties.\n\t\tmapper.setCurrentMap( mapper.lastPosition.map, true );\n\n\t\tb8.ECS.setLoc(\n\t\t\tmapper.player,\n\t\t\tmapper.lastPosition.col,\n\t\t\tmapper.lastPosition.row\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Update the game state.\n\t *\n\t * @param {number} dt - The delta time since the last update call.\n\t * @returns {void}\n\t */\n\tupdate: function( dt ) {\n\n\t\tb8.ECS.run( dt );\n\n\t},\n\n\n\t/**\n\t * Draw an actor at its location with optional offsets.\n\t *\n\t * @param {Object} actor - The actor entity with properties: id, col, row, fg, bg, animation.\n\t * @returns {void}\n\t */\n\tdrawActor: function( actor ) {\n\n\t\tconst screenPosition = mapper.camera.getScreenPosition( actor.col, actor.row );\n\n\t\tconst actorX = actor.col - screenPosition.col;\n\t\tconst actorY = actor.row - screenPosition.row;\n\n\t\t// Draw the actor at its position with the specified offset.\n\t\tb8.locate( actorX + offsetX, actorY + offsetY );\n\t\tb8.color( actor.fg, actor.bg );\n\t\tb8.drawActor( actor.id, actor.animation );\n\n\t},\n\n\n\t/**\n\t * Set a delay for key presses to prevent rapid actions.\n\t *\n\t * @returns {void}\n\t */\n\tdelayKeyPress: function( id ) {\n\n\t\tconsole.log( `Key press delay for entity ${id}` );\n\t\tb8.ECS.setComponent( id, 'ActionCooldown', { time: mapper.CONFIG.keyPressDelay } );\n\n\t},\n\n\n\t/**\n\t * Set the player's walking animation based on movement direction.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @param {number} dx - The change in x (column) direction.\n\t * @param {number} dy - The change in y (row) direction.\n\t * @returns {void}\n\t */\n\tsetPlayerWalkAnimation: function( playerId, dx, dy ) {\n\n\t\tconst anim = b8.ECS.getComponent( playerId, 'CharacterAnimation' );\n\n\t\tif ( dy > 0 ) anim.name = 'move-down';\n\t\tif ( dy < 0 ) anim.name = 'move-up';\n\t\tif ( dx > 0 ) anim.name = 'move-right';\n\t\tif ( dx < 0 ) anim.name = 'move-left';\n\n\t\tanim.duration = 0.3;\n\n\t},\n\n\n\t/**\n\t * Render all entities on the screen with optional offsets.\n\t *\n\t * @param {number} offsetX - Horizontal offset for rendering.\n\t * @param {number} offsetY - Vertical offset for rendering.\n\t * @returns {void}\n\t */\n\trender: function( offsetX = 0, offsetY = 0 ) {\n\n\t\t// Handy caches so look-ups are O(1) inside the loop\n\t\tconst list = [];\n\n\t\tfor ( const id of b8.ECS.query( 'Sprite', 'Loc' ) ) {\n\t\t\tconst spr = b8.ECS.getComponent( id, 'Sprite' );\n\t\t\tconst loc = b8.ECS.getComponent( id, 'Loc' );\n\t\t\tconst anim = b8.ECS.getComponent( id, 'CharacterAnimation' );\n\t\t\tlist.push( { spr, loc, anim } );\n\t\t}\n\n\t\t// nothing to draw\n\t\tif ( list.length === 0 ) return;\n\n\t\t// Depth-sort (default depth = 0)\n\t\tlist.sort( ( a, b ) => ( a.spr.depth ?? 0 ) - ( b.spr.depth ?? 0 ) );\n\n\t\t// Draw\n\t\tfor ( const { spr, loc, anim } of list ) {\n\n\t\t\tconst pos = mapper.camera.getTilePosition( loc.col, loc.row );\n\t\t\tconst nudgeCol = spr.nudgeCol || 0;\n\t\t\tconst nudgeRow = spr.nudgeRow || 0;\n\n\t\t\tb8.locate( pos.col + offsetX, pos.row + offsetY );\n\t\t\tb8.color( spr.fg ?? 15, spr.bg ?? 0 );\n\n\t\t\tswitch ( spr.type ) {\n\n\t\t\t\tcase 'actor':\n\n\t\t\t\t\tb8.drawActor( parseInt( spr.tile ), anim.name, nudgeCol, nudgeRow );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vfx':\n\n\t\t\t\t\tb8.Vfx.draw( spr.id, spr.startTime, nudgeCol, nudgeRow );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vfx-outline':\n\n\t\t\t\t\tb8.Vfx.drawOutline( spr.id, spr.startTime, nudgeCol, nudgeRow );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tb8.printChar( parseInt( spr.tile ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Draw the visible portion of the current map to the screen.\n\t *\n\t * @returns {void}\n\t */\n\tdrawScreen: function() {\n\n\t\tif ( !mapper.isValidMapId( mapper.currentMapId ) ) {\n\t\t\tb8.Utilities.fatal( \"No current map set.\" );\n\t\t\treturn;\n\t\t}\n\n\t\tlet loc = b8.ECS.getComponent( mapper.player, 'Loc' );\n\t\tif ( !loc ) loc = { col: 0, row: 0 };\n\t\tconst screenPosition = mapper.camera.getScreenPosition( loc.col, loc.row );\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\tb8.Tilemap.draw(\n\t\t\tcurrentMap.mapData,\n\t\t\tscreenPosition.col,\n\t\t\tscreenPosition.row,\n\t\t\tscreenPosition.w,\n\t\t\tscreenPosition.h\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Set a tile at the specified coordinates in the current map.\n\t *\n\t * @param {number} x - The x-coordinate (column) of the tile to set.\n\t * @param {number} y - The y-coordinate (row) of the tile to set.\n\t * @param {string} tile - The tile character to set at the specified coordinates.\n\t * @returns {void}\n\t */\n\tsetTile: function( x, y, tile ) {\n\n\t\tif ( !mapper.currentMap ) {\n\t\t\tb8.Utilities.error( \"No current map set.\" );\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tx < 0 ||\n\t\t\ty < 0 ||\n\t\t\ty >= mapper.currentMap.map.mapHeight ||\n\t\t\tx >= mapper.currentMap.map.mapWidth\n\t\t) {\n\t\t\tb8.Utilities.error( \"Mapper.setTile, coordinates out of bounds.\" );\n\t\t\treturn;\n\t\t}\n\n\t\tmapper.currentMap.map[ y ][ x ] = tile;\n\n\t},\n\n\n\t/**\n\t * Get the action verb for a given entity ID.\n\t *\n\t * @param {number} id - The entity ID to get the verb for.\n\t * @param {string} propertyName - The name of the property to retrieve.\n\t * @returns {string} The action verb associated with the entity, or an empty string if none exists.\n\t */\n\tgetPropForEntity: ( id, propertyName = null ) => {\n\n\t\tconst a = b8.ECS.getComponent( id, 'Action' );\n\n\t\tif ( !a ) return '';\n\t\tif ( !propertyName ) return '';\n\t\tif ( !( propertyName in a ) ) return '';\n\n\t\treturn a[ propertyName ] ?? '';\n\n\t},\n\n\n\t/**\n\t * Retrieve the currently active map.\n\t *\n\t * @returns {Object} The current map object.\n\t */\n\tgetCurrentMap: () => {\n\n\t\treturn mapper.maps[ mapper.currentMapId ];\n\n\t},\n\n\n\t/**\n\t * Get the pixel width of the current map.\n\t *\n\t * @returns {number} The width of the current map in tiles.\n\t */\n\tgetMapWidth: () => {\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\t\treturn currentMap.mapWidth;\n\n\t},\n\n\n\t/**\n\t * Get the pixel height of the current map.\n\t *\n\t * @returns {number} The height of the current map in tiles.\n\t */\n\tgetMapHeight: () => {\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\t\treturn currentMap.mapHeight;\n\n\t},\n\n\n\t/**\n\t * Get the action verb for the entity directly in front of the player.\n\t *\n\t * @param {number} playerId - The player entity ID.\n\t * @param {string|null} propertyName - The name of the property to retrieve.\n\t * @returns {string} The action verb of the entity ahead, or an empty string if none exists.\n\t */\n\tpromptAhead: ( playerId, propertyName = null ) => {\n\n\t\tif ( !propertyName ) return '';\n\n\t\tconst ids = mapper.entitiesAhead( playerId );\n\n\t\tfor ( const id of ids ) {\n\t\t\tconst verb = mapper.getPropForEntity( id, propertyName );\n\t\t\tif ( verb ) return verb;\n\t\t}\n\t\treturn '';\n\n\t},\n\n\n\t/**\n\t * Get the tile coordinates directly in front of the player.\n\t *\n\t * @param {number} playerId - The player entity ID.\n\t * @returns {Object} An object with x and y properties representing the tile coordinates ahead of the player.\n\t */\n\tahead: ( playerId ) => {\n\n\t\tconst loc = b8.ECS.getComponent( playerId, 'Loc' );\n\t\tconst dir = b8.ECS.getComponent( playerId, 'Direction' ); // {dx,dy}\n\n\t\tif ( !loc || !dir ) return { x: 0, y: 0 };\n\n\t\tconst x = loc.col + ( dir.dx || 0 );\n\t\tconst y = loc.row + ( dir.dy || 0 );\n\t\treturn { x, y };\n\n\t},\n\n\n\t/**\n\t * Get all entities located directly in front of the player.\n\t *\n\t * @param {number} playerId - The player entity ID.\n\t * @returns {Array} An array of entity IDs located ahead of the player.\n\t */\n\tentitiesAhead: ( playerId ) => {\n\n\t\tconst { x, y } = mapper.ahead( playerId );\n\t\treturn b8.ECS.entitiesAt( x, y ) ?? [];\n\n\t},\n\n\n\t/**\n\t * Get all entities located next to the player (up, down, left, right).\n\t *\n\t * @param {number} playerId - The player entity ID.\n\t * @returns {Array} An array of entity IDs located next to the player.\n\t */\n\tentitiesNextTo: ( playerId ) => {\n\n\t\tconst loc = b8.ECS.getComponent( playerId, 'Loc' );\n\t\tif ( !loc ) return [];\n\n\t\tconst adjacentEntities = new Set();\n\n\t\tconst directions = [\n\t\t\t{ dx: -1, dy: 0 }, // left\n\t\t\t{ dx: 1, dy: 0 },  // right\n\t\t\t{ dx: 0, dy: -1 }, // up\n\t\t\t{ dx: 0, dy: 1 }   // down\n\t\t];\n\n\t\tfor ( const dir of directions ) {\n\t\t\tconst x = loc.col + dir.dx;\n\t\t\tconst y = loc.row + dir.dy;\n\t\t\tconst entities = b8.ECS.entitiesAt( x, y );\n\t\t\tif ( entities ) {\n\t\t\t\tentities.forEach( id => adjacentEntities.add( id ) );\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from( adjacentEntities );\n\n\t},\n\n\n\t/**\n\t * Handle collision when the player attempts to move to a new tile.\n\t *\n\t * @param {number} x - The current x-coordinate (column) of the player.\n\t * @param {number} y - The current y-coordinate (row) of the player.\n\t * @param {number} newCol - The target x-coordinate (column) the player is moving to.\n\t * @param {number} newRow - The target y-coordinate (row) the player is moving to.\n\t * @param {number} dx - The change in x (column) direction.\n\t * @param {number} dy - The change in y (row) direction.\n\t * @return {boolean} True if the movement is blocked by a collision, false otherwise.\n\t */\n\tdoCollision: function( x, y, newCol, newRow, dx, dy ) {\n\n\t\t// ECS collision.\n\t\tif ( mapper.systems.tryPushing( x, y, dx, dy ) ) return true;\n\n\t\t// every entity occupying the target tile\n\t\tfor ( const id of b8.ECS.entitiesAt( newCol, newRow ) ) {\n\n\t\t\tconst typeComp = b8.ECS.getComponent( id, 'Type' );\n\t\t\tconst handler = typeComp ? mapper.types[ typeComp.name ] : null;\n\n\t\t\tif ( handler?.onCharacterCollision ) {\n\t\t\t\tconst blocked = handler.onCharacterCollision( id, newCol, newRow, dx, dy );\n\t\t\t\tif ( blocked ) return true;\n\t\t\t}\n\n\t\t\tconst isSolid = b8.ECS.hasComponent( id, 'Solid' );\n\t\t\tif ( isSolid ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\n\t/**\n\t * Perform the action associated with the entity directly in front of the player.\n\t *\n\t * @param {number} playerId - The player entity ID.\n\t * @param {string} propertyName - The name of the property to check for an action.\n\t * @returns {boolean} True if an action was performed, false otherwise.\n\t */\n\tdoAction: ( playerId, propertyName ) => {\n\n\t\tif ( !propertyName ) return false;\n\n\t\tconst ac = b8.ECS.getComponent( playerId, 'ActionCooldown' );\n\t\tif ( !ac ) {\n\t\t\tmapper.delayKeyPress( playerId );\n\t\t} else {\n\t\t\tif ( ac.time > 0 ) return false;\n\t\t}\n\n\t\tconst action = mapper.promptAhead( playerId, propertyName );\n\n\t\tif ( action && mapper.actions[ action ] ) {\n\t\t\tmapper.actions[ action ]( playerId );\n\t\t}\n\n\t\tmapper.delayKeyPress( playerId );\n\n\t\treturn true;\n\n\t},\n\n\n\t/**\n\t * Perform an attack action by the player.\n\t *\n\t * @param {number} playerId - The player entity ID.\n\t * @param {string} propertyName - The name of the property to check for an attack action.\n\t * @returns {void}\n\t */\n\tdoAttack: ( playerId, propertyName ) => {\n\n\t\tif ( !mapper.doAction( playerId, propertyName ) ) return;\n\n\t\tconst ahead = mapper.ahead( playerId );\n\n\t\t// Do swipe VFX.\n\t\tmapper.types.vfx.spawn(\n\t\t\tahead.x, ahead.y,\n\t\t\t{ id: 'swipe', fg: 15, bg: 0, type: 'vfx-outline' }\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Update the move delay to control player movement speed.\n\t *\n\t * @param {number} amount - The amount of delay to set (in seconds).\n\t * @returns {void}\n\t */\n\tupdateMoveDelay: function( amount = mapper.CONFIG.moveDelay ) {\n\n\t\t// We use Math.max to ensure we don't reduce an existing longer delay.\n\t\tmapper.sceneGame.moveDelay = Math.max( amount, mapper.sceneGame.moveDelay );\n\n\t},\n\n\n\t/**\n\t * Check if the provided map ID is valid.\n\t *\n\t * @param {number} mapId - The map ID to validate.\n\t * @returns {boolean} True if the map ID is valid, false otherwise.\n\t */\n\tisValidMapId: ( mapId ) => {\n\n\t\treturn typeof mapId === 'number' && mapId >= 0;\n\n\t},\n\n\n\t/**\n\t * Check if there is an entity of a specific type at the given coordinates.\n\t *\n\t * @param {number} col - The column coordinate to check.\n\t * @param {number} row - The row coordinate to check.\n\t * @param {string} type - The type of the entity to look for.\n\t * @returns {boolean} True if an entity of the specified type exists at the coordinates, false otherwise.\n\t */\n\thasEntityAt: function( col, row, type ) {\n\n\t\tconst entities = b8.ECS.entitiesAt( col, row );\n\n\t\tfor ( const id of entities ) {\n\t\t\tconst typeComp = b8.ECS.getComponent( id, 'Type' );\n\t\t\tif ( typeComp?.name === type ) return true;\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\n\t/**\n\t * Remove an object of a specific type at the given coordinates from the current map.\n\t *\n\t * @param {number} col - The column coordinate of the object to remove.\n\t * @param {number} row - The row coordinate of the object to remove.\n\t * @param {string} type - The type of the object to remove.\n\t * @returns {void}\n\t */\n\tremoveObjectAt: function( col, row, type ) {\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\t// Filter out the object matching the specified coordinates and type.\n\t\tcurrentMap.objects = currentMap.objects.filter(\n\t\t\t( obj ) => !( obj.x === col && obj.y === row && obj.type.startsWith( type ) )\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Change properties of an object at the given coordinates in the current map.\n\t *\n\t * @param {number} col - The column coordinate of the object to change.\n\t * @param {number} row - The row coordinate of the object to change.\n\t * @param {string} type - The current type of the object to change.\n\t * @param {Object} properties - An object containing the properties to update.\n\t * @returns {void}\n\t */\n\tchangeObjectPropertiesAt: function( col, row, type, properties = {} ) {\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\t// Find the object matching the specified coordinates and type.\n\t\tfor ( const obj of currentMap.objects ) {\n\t\t\tif ( obj.x === col && obj.y === row && obj.type.startsWith( type ) ) {\n\t\t\t\tObject.assign( obj, properties );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Change the type of an object at the given coordinates in the current map.\n\t *\n\t * @param {number} col - The column coordinate of the object to change.\n\t * @param {number} row - The row coordinate of the object to change.\n\t * @param {string} type - The current type of the object to change.\n\t * @param {string} newType - The new type to set for the object.\n\t * @returns {void}\n\t */\n\tchangeObjectTypeAt: function( col, row, type, newType ) {\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\t// Find the object matching the specified coordinates and type.\n\t\tfor ( const obj of currentMap.objects ) {\n\t\t\tif ( obj.x === col && obj.y === row && obj.type.startsWith( type ) ) {\n\t\t\t\tobj.type = newType;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Give rewards to the player.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @param {Array} rewards - An array of reward objects to give to the player.\n\t * @returns {void}\n\t */\n\tgiveRewards: function( playerId, rewards = [] ) {\n\n\t\tif ( !rewards || rewards.length === 0 ) return;\n\n\t\trewards.forEach(\n\t\t\t( reward ) => {\n\n\t\t\t\tif ( !reward.type ) return;\n\t\t\t\tif ( !reward.props ) reward.props = {};\n\n\t\t\t\tconst fn = mapper.types[ reward.type ]?.pickupHandler;\n\t\t\t\tif ( fn ) fn( playerId, reward );\n\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Invoke a handler function for a given entity based on its type.\n\t *\n\t * @param {number} entityId - The entity ID to invoke the handler for.\n\t * @param {string} handlerName - The name of the handler function to invoke.\n\t * @returns {boolean} The result of the handler function, or false if not found.\n\t */\n\tdoHandler: function( entityId, handlerName ) {\n\n\t\t// Retrieve the Type component for the given entity ID\n\t\tconst type = b8.ECS.getComponent( entityId, 'Type' );\n\t\tconst handler = type && mapper.types[ type.name ];\n\n\t\tif ( handler?.[ handlerName ] ) return handler[ handlerName ]( entityId );\n\n\t\treturn false;\n\n\t},\n\n\n\t/**\n\t * Repeat the last step of a path a specified number of times.\n\t *\n\t * @param {Array} path - The path array to modify.\n\t * @param {number} count - The number of times to repeat the last step.\n\t * @returns {void}\n\t */\n\trepeatLastValue: function( path, count ) {\n\n\t\tconst last = path.at( -1 );\n\t\tpath.push( ...Array( count ).fill( last ) );\n\n\t},\n\n};\n\n\nmapper.CONFIG = {\n\n\t// Time in seconds for player movement delay.\n\tmoveDelay: 0.2,\n\n\tactionDelay: 0.5,\n\n\t// Time in seconds for player to not take damage after being hit.\n\thealthCooldown: 1.2,\n\n\t// Key press delay.\n\tkeyPressDelay: 0.25,\n\n\t// Time in seconds between AI updates.\n\taiUpdateDelay: 0.5,\n\n\t/**\n\t * Offset to apply when drawing the map and actors.\n\t * This is to account for any borders or UI elements.\n\t */\n\tmapOffsetX: 1,\n\tmapOffsetY: 1,\n\n\t// UI graphics.\n\tgameUI: `hpgYhRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGGEIAACghRhhCAAAoIUYYQgAAKCFGJUHAACghRiVBwAAoIUYlQcAAKCFGJUKAACgmBiFGBwHBgCghRgZBwYAoIUYGQcGAKCFGBkHBgCghRgZBwYAoIUYGQcGAKCFDAYHAKCFGBkHBgCghRgZBwYAoIUYGQcGAKCFGBkHBgCghRgZBwYAoIUYGQcGAKCFGBkHBgCghRgZBwYAoIUYGQcGAKCFGBkHBgCghRgZBwYAoIUYGQcGAKCFGB0HBgCghRgZBwgAoIUYIAgHAKCFGCsHBgCghRkBXAoAAKCYGIUYKwYHAKCFEgAHAKCFAAgAAKCFAAgAAKCFAAgAAKCFAwEAAKCFAAgAAKCFAA8AAKCFEwAHAKCFAQcGAKCFGQG0CgcAoIUBBwYAoIUBBwYAoIUBBwYAoIUZAbUKBwCghQEHBgCghQEHBgCghQEHBgCghQEHBgCghREGBwCghQAAAACghRMABwCghRgrBwYAoIUZAV4KAACgmBiFGCsGBwCghQEABwCghRkBnwgAAKCFGQGfCAAAoIUZAZ8IAACghRkBnwgAAKCFGQGfCAAAoIUZAZ8IAACghQEABwCghRg9AAEAoIUYPQABAKCFGD0AAQCghRg9AAEAoIUYPQABAKCFGD0AAQCghRg9AAEAoIUYPQABAKCFGD4AAQCghQEHBgCghRgrBwYAoIUAAAAAoIUAAAAAoIUYKwcGAKCFGQFdCgAAoJgYhRgrBgcAoIUBAAcAoIUBAAEAoIUADgAAoIUADwAAoIUADwAAoIUADwAAoIUADwAAoIUAAQAAoIUABQEAoIUBAQcAoIUBAQcAoIUBAQcAoIUBAQcAoIUBAQcAoIUBAQcAoIUBAQcAoIUYUAABAKCFAAYHAKCFGCsHBgCghQAAAACghRglAAcAoIUYKwcGAKCFGQFeCgAAoJgYhRguBwYAoIUBAAEAoIUAAQAAoIUAAQAAoIUAAQAAoIUAAQAAoIURAQAAoIURAQAAoIUBAAEAoIUYYQABAKCFGGEAAQCghRhhAAEAoIUYYQABAKCFGGEAAQCghRhhAAEAoIURBgEAoIURBgEAoIUYYgABAKCFEQYHAKCFGC8HBgCghRgZBgcAoIUYGQYHAKCFGDEHBgCghRkBXQoAAKA=`,\n\n};\n\n\nmapper.actions.attack = ( playerId ) => {\n\n\tconst ids = mapper.entitiesAhead( playerId );\n\n\tfor ( const targetId of ids ) {\n\n\t\t// Don't attack self.\n\t\tif ( targetId === playerId ) continue;\n\n\t\t// Only attack entities that can be attacked.\n\t\tif ( !b8.ECS.hasComponent( targetId, 'AttackTarget' ) ) continue;\n\n\t\t// Apply damage to the target.\n\t\tconst targetHealth = b8.ECS.getComponent( targetId, 'Health' );\n\t\tconst playerAttack = b8.ECS.getComponent( playerId, 'Attack' ) || { value: 1 };\n\t\ttargetHealth.value -= playerAttack.value;\n\n\t}\n\n};\nmapper.actions.ignite = function( playerId ) {\n\n\tconst ids = mapper.entitiesAhead( playerId );\n\n\tfor ( const targetId of ids ) {\n\n\t\t// Don't ignite self.\n\t\tif ( targetId === playerId ) continue;\n\n\t\t// Ignite the bomb.\n\t\tconst bomb = b8.ECS.getComponent( targetId, 'Bomb' );\n\t\tif ( !bomb ) continue;\n\n\t\t// Start the fuse.\n\t\tbomb.fuseTime = 5;\n\n\t};\n\n};\nmapper.actions.open = async function( playerId ) {\n\n\tconst entities = mapper.entitiesAhead( playerId );\n\n\tfor ( const id of entities ) {\n\n\t\tconst obj = b8.ECS.getComponent( id, 'Openable' );\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\n\t\tif ( !obj || !sprite ) continue;\n\n\t\t// Change the tile.\n\t\tif ( obj.openedTile ) sprite.tile = obj.openedTile;\n\n\t\t// Change the master map object type if specified.\n\t\t// This prevents re-opening the chest on when reloading the map.\n\t\tif ( obj.newType ) {\n\t\t\tconst loc = b8.ECS.getComponent( id, 'Loc' );\n\t\t\tconst type = b8.ECS.getComponent( id, 'Type' );\n\t\t\tmapper.changeObjectTypeAt( loc.col, loc.row, type.name, obj.newType );\n\t\t}\n\n\t\t// Play sound effect.\n\t\tb8.Sfx.play( 'tone/jingle/017' );\n\n\t\t// Display message if specified.\n\t\tif ( obj.message ) {\n\t\t\tb8.color(\n\t\t\t\tsprite.fg ?? 15,\n\t\t\t\tsprite.bg ?? 5\n\t\t\t);\n\n\t\t\tconst message = mapper.helpers.processChatText( obj.message || '' );\n\t\t\tawait b8.Async.dialogTypewriter( message, [ \"OK\" ], 20 );\n\t\t}\n\n\t\t// Rewards.\n\t\tconst rewards = b8.ECS.getComponent( id, 'Reward' );\n\t\tmapper.giveRewards( playerId, rewards?.items || [] );\n\n\t\t// Clean up components.\n\t\tb8.ECS.removeComponent( id, 'Reward' );\n\t\tb8.ECS.removeComponent( id, 'Action' );\n\t\tb8.ECS.removeComponent( id, 'Openable' );\n\n\t\t// If message then change the entity to a Signpost entity and change the\n\t\t// action verb to read.\n\t\tconst messageComponent = b8.ECS.getComponent( id, 'Message' );\n\t\tif ( messageComponent?.message?.length > 0 ) {\n\t\t\tb8.ECS.addComponent( id, 'Action', { ButtonA: 'read', ButtonB: 'read' } );\n\t\t}\n\n\t\tmapper.delayKeyPress( id );\n\n\t\treturn;\n\n\t}\n\n};\nmapper.actions.pull = function( playerId ) {\n\n\tconst loc = b8.ECS.getComponent( playerId, 'Loc' );\n\tconst dir = b8.ECS.getComponent( playerId, 'Direction' ); // {dx,dy}\n\n\tmapper.systems.tryPulling( loc.col, loc.row, dir.dx, dir.dy, playerId );\n\n};\nmapper.actions.read = async function( playerId ) {\n\n\tconst entities = mapper.entitiesAhead( playerId );\n\n\tfor ( const id of entities ) {\n\n\t\tconst obj = b8.ECS.getComponent( id, 'Message' );\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\n\t\tif ( !obj || !sprite ) continue;\n\n\t\tb8.color(\n\t\t\tsprite.fg ?? 15,\n\t\t\tsprite.bg ?? 5\n\t\t);\n\n\t\tconst message = mapper.helpers.processChatText( obj.message || '' );\n\t\tawait b8.Async.dialogTypewriter( message, [ \"OK\" ], 20 );\n\n\t\tmapper.delayKeyPress( id );\n\n\t\treturn;\n\n\t}\n\n};\n/**\n * A generic action trigger handler.\n *\n * Will execute the handleTrigger logic for each entity in front of the player.\n * This can be used for any random one off properties with the code added to the\n * entity type's handleTrigger function.\n *\n * @param {number} playerId - The entity ID of the player.\n * @returns {void}\n */\nmapper.actions.trigger = function( playerId ) {\n\n\tconst ids = mapper.entitiesAhead( playerId );\n\n\tfor ( const targetId of ids ) {\n\n\t\tconst type = b8.ECS.getComponent( targetId, 'Type' );\n\n\t\tif ( mapper.types[ type.name ]?.triggerHandler ) {\n\t\t\tmapper.types[ type.name ].triggerHandler( playerId, targetId );\n\t\t}\n\n\t}\n\n};\n\n\nmapper.ai = {\n\n\tMODE: {\n\t\tNONE: 'none',\n\t\tRETURN: 'return',\n\t\tCHASE: 'chase',\n\t\tATTACK: 'attack',\n\t\tFLEE: 'flee',\n\t\tLOOT: 'loot',\n\t\tWANDER: 'wander',\n\t\tPATROL: 'patrol',\n\t\tCHASE_LAST_SEEN: 'chase_last_seen',\n\t},\n\n\n\t/**\n\t * Is location b next to (adjacent to) location a?\n\t *\n\t * @param {Object} a - The first location with col and row properties.\n\t * @param {Object} b - The second location with col and row properties.\n\t * @returns {boolean} True if the locations are adjacent, false otherwise.\n\t */\n\tisAdjacent: ( a, b ) => {\n\n\t\treturn b8.Math.distManhattan( a, b ) === 1;\n\n\t},\n\n\n\t/**\n\t * Get the direction from one location to another.\n\t * Returns a direction object with dx and dy.\n\t *\n\t * @param {Object} from - The starting location with col and row properties.\n\t * @param {Object} to - The target location with col and row properties.\n\t * @returns {Object} An object with dx and dy properties representing the direction.\n\t */\n\tdirTo: ( from, to ) => {\n\n\t\tif ( to.col > from.col ) return { dx: 1, dy: 0 };\n\t\tif ( to.col < from.col ) return { dx: -1, dy: 0 };\n\t\tif ( to.row > from.row ) return { dx: 0, dy: 1 };\n\t\tif ( to.row < from.row ) return { dx: 0, dy: -1 };\n\n\t\treturn { dx: 0, dy: 0 };\n\n\t},\n\n\n\t/**\n\t * Is the 'from' location facing the to location based on direction?\n\t *\n\t * @param {Object} from - The id of the entity in the from location.\n\t * @param {Object} to - The id of the entity in the to location.\n\t * @returns {boolean} True if 'to' is in front of 'from', false otherwise.\n\t */\n\tisFacing: ( from, to ) => {\n\n\t\tb8.Utilities.checkInt( \"from\", from );\n\t\tb8.Utilities.checkInt( \"to\", to );\n\n\t\tconst fromDir = b8.ECS.getComponent( from, 'Direction' );\n\t\tconst fromLoc = b8.ECS.getComponent( from, 'Loc' );\n\t\tconst toLoc = b8.ECS.getComponent( to, 'Loc' );\n\n\t\tconst d = mapper.ai.dirTo( fromLoc, toLoc );\n\n\t\treturn fromDir.dx === d.dx && fromDir.dy === d.dy;\n\n\t},\n\n\n\tface: ( from, to ) => {\n\n\t\tconst direction = mapper.ai.dirTo( from, to );\n\n\t\tb8.ECS.setComponent(\n\t\t\tfrom,\n\t\t\t'Direction',\n\t\t\tdirection\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Is the 'to' location behind the 'from' location based on direction?\n\t *\n\t * @param {Object} direction - The direction object with dx and dy.\n\t * @param {Object} from - The starting location with col and row properties.\n\t * @param {Object} to - The target location with col and row properties.\n\t * @returns {boolean} True if 'to' is behind 'from', false otherwise.\n\t */\n\tisBehind: ( direction, from, to ) => {\n\n\t\tconst d = mapper.ai.dirTo( from, to );\n\n\t\treturn direction.dx === -d.dx && direction.dy === -d.dy;\n\n\t},\n\n\n\t/**\n\t * Determine if there is a line of sight between two locations within a given range,\n\t * considering solid obstacles.\n\t *\n\t * Uses Bresenham's algorithm to step to next tile.\n\t *\n\t * Bresenham's line algorithm is used here to determine which tiles\n\t * the line passes through, allowing us to check for obstacles.\n\t *\n\t * The algorithm works by calculating the error term to decide\n\t * when to step in the y-direction while iterating over x (or vice versa).\n\t *\n\t * The error term refers to the difference between the ideal line and the actual\n\t * rasterized line. By adjusting the error term, we can determine when to\n\t * increment the y-coordinate as we move along the x-axis (or vice versa),\n\t * ensuring that we stay as close to the ideal line as possible.\n\t *\n\t * @see https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm\n\t *\n\t * @param { Object } from - The starting location with col and row properties.\n\t * @param { Object } to - The target location with col and row properties.\n\t * @param { number } range - The maximum range for line of sight.\n\t * @param { Function } solidsFn - A function that takes( col, row ) and returns true if the tile is solid.\n\t * @returns { boolean } True if there is line of sight, false otherwise.\n\t */\n\thasLineOfSight: ( fromId, toId, range = 5, solidsFn = mapper.collision.isFree ) => {\n\n\t\tconst from = b8.ECS.getComponent( fromId, 'Loc' );\n\t\tconst to = b8.ECS.getComponent( toId, 'Loc' );\n\n\t\tconst dist = b8.Math.dist2d( from.col, from.row, to.col, to.row );\n\t\tif ( dist > range ) return false; // Ensure the target is within range\n\t\tif ( dist <= 1 ) return true; // Adjacent tiles always have line of sight\n\n\t\treturn true; // TEMP OVERRIDE FOR TESTING\n\n\t\tlet x0 = from.col;\n\t\tlet y0 = from.row;\n\t\tlet x1 = to.col;\n\t\tlet y1 = to.row;\n\n\t\tlet dx = Math.abs( x1 - x0 );\n\t\tlet dy = Math.abs( y1 - y0 );\n\n\t\tlet sx = x0 < x1 ? 1 : -1;\n\t\tlet sy = y0 < y1 ? 1 : -1;\n\n\t\tlet err = dx - dy;\n\n\t\tlet whileCount = 0;\n\n\t\twhile ( true ) {\n\n\t\t\twhileCount++;\n\n\t\t\tconst tileSize = b8.CONFIG.CHR_WIDTH;\n\t\t\tb8.drawRect( x0 * tileSize, y0 * tileSize, tileSize, tileSize, 2 );\n\n\t\t\t// Skip starting tile.\n\t\t\tif ( !( x0 === from.col && y0 === from.row ) ) {\n\t\t\t\tif ( solidsFn( x0, y0 ) ) {\n\t\t\t\t\treturn false; // Obstacle blocks the line of sight\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Reached destination.\n\t\t\tif ( x0 === x1 && y0 === y1 ) return true;\n\n\t\t\tconst e2 = err * 2;\n\n\t\t\tif ( e2 > -dy ) {\n\t\t\t\terr -= dy;\n\t\t\t\tx0 += sx;\n\t\t\t}\n\n\t\t\tif ( e2 < dx ) {\n\t\t\t\terr += dx;\n\t\t\t\ty0 += sy;\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Can the attacker attack the target based on adjacency and facing direction?\n\t *\n\t * @param {Object} attacker - The attacker entity with Loc and Direction components.\n\t * @param {Object} target - The target entity with Loc component.\n\t * @returns {boolean} True if the attacker can attack the target, false otherwise.\n\t */\n\tcanAttack: ( attacker, target ) => {\n\n\t\tconst attackerLoc = b8.ECS.getComponent( attacker, 'Loc' );\n\t\tconst targetLoc = b8.ECS.getComponent( target, 'Loc' );\n\n\t\tif ( !attackerLoc || !targetLoc ) return false;\n\n\t\tif ( !mapper.ai.isAdjacent( attackerLoc, targetLoc ) ) return false;\n\n\t\treturn true;\n\n\t\t// return mapper.ai.isFacing( attacker, target );\n\n\t},\n\n\n\t/**\n\t * Perform A* pathfinding from start to goal and set the PathIntent component.\n\t *\n\t * @param {number} id - The entity ID of the character to move.\n\t * @param {Object} start - The starting location with col and row properties.\n\t * @param {Object} goal - The target location with col and row properties.\n\t * @returns {void}\n\t */\n\tdoAstar: ( start, goal ) => {\n\n\t\treturn b8.AStar.pathfind(\n\t\t\tstart,\n\t\t\tgoal,\n\t\t\tmapper.collision.isFree,\n\t\t\tmapper.getMapWidth(),\n\t\t\tmapper.getMapHeight()\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Find the nearest loot item to the enemy within a specified range.\n\t *\n\t * @param {Object} enemyLoc - The location of the enemy with col and row properties.\n\t * @param {Array} items - An array of item entities with Loc components.\n\t * @param {number} maxRange - The maximum range to consider for loot.\n\t * @returns {Object|null} The nearest loot item entity or null if none found.\n\t */\n\tfindNearestLoot: ( enemyLoc, items, maxRange ) => {\n\n\t\tlet best = null;\n\t\tlet bestDist = Infinity;\n\n\t\titems.forEach(\n\n\t\t\t( item ) => {\n\n\t\t\t\tconst d = b8.Math.distManhattan( enemyLoc, item.Loc );\n\n\t\t\t\tif ( d <= maxRange && d < bestDist ) {\n\t\t\t\t\tbest = item;\n\t\t\t\t\tbestDist = d;\n\t\t\t\t}\n\n\t\t\t}\n\t\t);\n\n\t\treturn best;\n\n\t},\n\n\n\t/**\n\t * Find a random nearby tile within a given radius that satisfies the walkable condition.\n\t *\n\t * @param {Object} from - The starting location with col and row properties.\n\t * @param {number} radius - The radius within which to search for a tile.\n\t * @returns {Object|null} A location object with col and row properties or null if none found.\n\t */\n\trandomNearbyTile: ( from, radius ) => {\n\n\t\tconst tries = 10;\n\n\t\t// Try and find a safe tile first.\n\t\tfor ( let i = 0; i < tries; i++ ) {\n\n\t\t\tconst col = from.col + b8.Random.int( -radius, radius );\n\t\t\tconst row = from.row + b8.Random.int( -radius, radius );\n\n\t\t\tif (\n\t\t\t\tmapper.collision.isWalkable( col, row ) &&\n\t\t\t\tmapper.collision.isSafe( col, row )\n\t\t\t) {\n\t\t\t\treturn { col, row };\n\t\t\t}\n\n\t\t}\n\n\t\t// Can't find a safe tile, try for any walkable tile.\n\t\tfor ( let i = 0; i < tries; i++ ) {\n\n\t\t\tconst col = from.col + b8.Random.int( -radius, radius );\n\t\t\tconst row = from.row + b8.Random.int( -radius, radius );\n\n\t\t\tif ( mapper.collision.isWalkable( col, row ) ) return { col, row };\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\n\t/**\n\t * Find the index of the nearest tile in a path to a given location.\n\t *\n\t * @param {Object} loc The location with col and row properties.\n\t * @param {Array} tiles An array of tile locations with col and row properties.\n\t * @returns {number} The index of the nearest tile in the path.\n\t */\n\tnearestPathIndex: ( loc, tiles ) => {\n\n\t\tlet best = 0;\n\t\tlet bestDist = Infinity;\n\n\t\tfor ( let i = 0; i < tiles.length; i++ ) {\n\t\t\tconst d = b8.Math.distManhattan( loc, { col: tiles[ i ].col, row: tiles[ i ].row } );\n\t\t\tif ( d < bestDist ) {\n\t\t\t\tbestDist = d;\n\t\t\t\tbest = i;\n\t\t\t}\n\t\t}\n\n\t\treturn best;\n\n\t},\n\n\n\t/**\n\t * Check if a location is on a given path of tiles.\n\t *\n\t * @param {Object} loc The location with col and row properties.\n\t * @param {Array} tiles An array of tile locations with col and row properties.\n\t * @param {number} maxDist The maximum distance to consider as \"on the path\".\n\t * @returns {Object} An object with onPath (boolean) and index (number) properties.\n\t */\n\tisOnPath: ( loc, tiles, maxDist = 0 ) => {\n\n\t\tfor ( let i = 0; i < tiles.length; i++ ) {\n\t\t\tif ( b8.Math.distManhattan( loc, { col: tiles[ i ].x, row: tiles[ i ].y } ) <= maxDist ) {\n\t\t\t\treturn { near: true, index: i, onPath: true };\n\t\t\t}\n\t\t}\n\n\t\treturn { onPath: false, index: -1 };\n\n\t},\n\n\n\tthink: ( id ) => {\n\n\t\tconst ai = b8.ECS.getComponent( id, 'AI' );\n\n\t\t// Flee if on fire.\n\t\tif ( b8.ECS.hasComponent( id, 'OnFire' ) ) {\n\t\t\treturn mapper.ai.MODE.FLEE;\n\t\t}\n\n\t\tif ( mapper.ai.canAttack( id, mapper.player ) ) {\n\t\t\treturn mapper.ai.MODE.ATTACK;\n\t\t}\n\n\t\t// Chase player if visible.\n\t\tconst canSeePlayer = mapper.ai.hasLineOfSight( id, mapper.player );\n\t\tif ( canSeePlayer ) {\n\t\t\treturn mapper.ai.MODE.CHASE;\n\t\t}\n\n\t\t// Follow path.\n\t\tif ( ai.path && ai.path.length > 0 ) {\n\t\t\treturn mapper.ai.MODE.PATROL;\n\t\t}\n\n\t\t// Wander by default.\n\t\treturn mapper.ai.MODE.WANDER;\n\n\t},\n\n\n\ttoXY: ( loc ) => ( { x: loc.col, y: loc.row } ),\n\n\ttoLoc: ( xy ) => ( { col: xy.x, row: xy.y } ),\n\n\n};\n\nmapper.camera = {\n\n\t/**\n\t * Get the top-left tile coordinates of the screen the player is currently on.\n\t *\n\t * @param {number} pCol - The player's column position.\n\t * @param {number} pRow - The player's row position.\n\t * @returns {Object} An object with col, row, w, and h properties representing the screen's top-left tile and dimensions.\n\t */\n\tgetScreenPosition: function( pCol, pRow ) {\n\n\t\tif ( !mapper.isValidMapId( mapper.currentMapId ) ) {\n\t\t\tb8.Utilities.error( \"No current map set.\" );\n\t\t\treturn { col: 0, row: 0 };\n\t\t}\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\tconst screenWidth = currentMap.screenWidth;\n\t\tconst screenHeight = currentMap.screenHeight;\n\n\t\t// Calculate which screen to draw based on player position.\n\t\tconst screenX = Math.floor( pCol / screenWidth ) * screenWidth;\n\t\tconst screenY = Math.floor( pRow / screenHeight ) * screenHeight;\n\n\t\treturn { col: screenX, row: screenY, w: screenWidth, h: screenHeight };\n\n\t},\n\n\n\t/**\n\t * Get the on-screen tile coordinates for a given map tile.\n\t *\n\t * @param {number} col - The map tile's column position.\n\t * @param {number} row - The map tile's row position.\n\t * @returns {Object} An object with col and row properties representing the tile's on-screen position.\n\t */\n\tgetTilePosition: function( col, row ) {\n\n\t\tconst loc = b8.ECS.getComponent( mapper.player, 'Loc' );\n\n\t\tif ( !loc ) return { col: 0, row: 0 };\n\n\t\tconst pos = mapper.camera.getScreenPosition( loc.col, loc.row );\n\n\t\tlet tileCol = col - pos.col;\n\t\tlet tileRow = row - pos.row;\n\n\t\t// If out of bounds push off the screen to avoid rendering.\n\t\tif ( tileCol < 0 ) tileCol = -100;\n\t\tif ( tileRow < 0 ) tileRow = -100;\n\t\tif ( tileCol >= pos.w ) tileCol = -100;\n\t\tif ( tileRow >= pos.h ) tileRow = -100;\n\n\t\treturn {\n\t\t\tcol: tileCol,\n\t\t\trow: tileRow,\n\t\t};\n\n\t},\n\n};\nmapper.collision = {\n\n\t/**\n\t * Check if there is a solid object at (col,row).\n\t *\n\t * @param {number} col\n\t * @param {number} row\n\t * @returns {boolean}\n\t */\n\tisSolid: ( col, row ) => {\n\n\t\treturn b8.ECS.entitiesAt( col, row ).some( id => b8.ECS.hasComponent( id, 'Solid' ) );\n\n\t},\n\n\n\t/**\n\t * Check if (col,row) is safe (no hazards like fire).\n\t *\n\t * @param {number} col\n\t * @param {number} row\n\t * @returns {boolean}\n\t */\n\tisSafe: ( col, row ) => {\n\n\t\treturn !b8.ECS.entitiesAt( col, row ).some( id => b8.ECS.hasComponent( id, 'Fire' ) );\n\n\t},\n\n\n\t/**\n\t * Check if (col,row) is free (walkable and no solid object).\n\t *\n\t * @param {number} col\n\t * @param {number} row\n\t * @returns {boolean}\n\t */\n\tisFree: ( col, row ) => {\n\n\t\treturn mapper.collision.isWalkable( col, row ) && !mapper.collision.isSolid( col, row );\n\n\t},\n\n\n\t/**\n\t * Check if (col,row) is walkable (not a wall or closed door).\n\t *\n\t * @param {number} col\n\t * @param {number} row\n\t * @returns {boolean}\n\t */\n\tisWalkable: function( col, row ) {\n\n\t\tconst currentMap = mapper.getCurrentMap();\n\n\t\t// Check bounds.\n\t\tif (\n\t\t\tcol < 0 ||\n\t\t\trow < 0 ||\n\t\t\tcol >= currentMap.mapWidth ||\n\t\t\trow >= currentMap.mapHeight\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check current tile collision properties.\n\t\tlet mapCell = currentMap.mapData[ row ][ col ];\n\t\tif ( true === mapCell[ 3 ] ) return false;\n\n\t\treturn true;\n\n\t},\n\n};\nmapper.helpers = {\n\n\t/**\n\t * Capitalize the first letter of each word in a string.\n\t *\n\t * @param {string} str Input string\n\t * @returns {string} Capitalized string\n\t */\n\tcapitalizeWords: ( str ) => {\n\n\t\treturn str.replace( /\\b\\p{L}/gu, c => c.toUpperCase() )\n\n\t},\n\n\n\t/**\n\t * Process chat text, replacing tokens with dynamic values.\n\t *\n\t * @param {string} str Input string\n\t * @returns {string} Processed string\n\t */\n\tprocessChatText: ( str ) => {\n\n\t\t// Replace [levelName] with the actual level name.\n\t\tstr = str.replace( /\\[levelName\\]/g, b8.data.levelName ?? 'Unknown' );\n\n\t\t// Replace [playerName] with the actual player name.\n\t\tstr = str.replace( /\\[playerName\\]/g, b8.data.playerName ?? 'Player' );\n\n\t\t// Replace [totalCoins] with the actual total coins value.\n\t\tstr = str.replace( /\\[totalCoins\\]/g, b8.data.totalCoins ?? '0' );\n\n\t\treturn str;\n\n\t},\n\n\n\t/**\n\t * Get all map objects of a given type.\n\t *\n\t * @param {string} type The object type to search for.\n\t * @returns {Object[]} Array of matching objects.\n\t */\n\tgetObjectsByType: ( type ) => {\n\n\t\tconst objects = [];\n\n\t\tfor ( let l = 0; l < mapper.maps.length; l++ ) {\n\t\t\tconst map = mapper.maps[ l ];\n\t\t\tfor ( const obj of map.objects ) {\n\t\t\t\t// Support type prefixes, e.g., \"door\" matches \"doorway\", \"doorLarge\", etc.\n\t\t\t\tif ( obj.type.startsWith( type ) ) objects.push( obj );\n\t\t\t}\n\t\t}\n\n\t\treturn objects;\n\n\t},\n\n}\n/**\n * Load a map into the game.\n *\n * @param {Object} mapData - The map data object containing map layout, tiles, objects, and settings.\n * @returns {void}\n */\nmapper.load = function( mapData ) {\n\n\t// It's a new game so reset everything.\n\tb8.ECS.reset();\n\tmapper.maps = [];\n\tmapper.settings = {};\n\tmapper.currentMapId = null;\n\n\tb8.Utilities.checkObject( 'mapData', mapData );\n\n\tif ( mapData.version === 1 ) mapData = mapper.upgradeMapDataV1toV2( mapData );\n\n\tmapper.settings = { ...mapData.settings };\n\tb8.Utilities.checkObject( 'mapper.settings', mapper.settings );\n\n\t// Loop through levels and set them up.\n\tmapData.levels.forEach(\n\t\t( level, index ) => {\n\n\t\t\tconst mapDataString = level.mapData.join( '\\n' );\n\t\t\tb8.Utilities.checkString( `mapDataString for level ${index}`, mapDataString );\n\n\t\t\tconst mapArray = b8.Tilemap.convertFromText( mapDataString );\n\t\t\tconst map = b8.Tilemap.createFromArray( mapArray, mapData.tiles );\n\n\t\t\t// Add mapId to each object\n\t\t\tconst objects = ( level.objects || [] ).map(\n\t\t\t\tobj => ( { ...obj, mapId: index } )\n\t\t\t);\n\n\t\t\tmapper.maps.push(\n\t\t\t\t{\n\t\t\t\t\t\"screenWidth\": mapData.screenWidth,\n\t\t\t\t\t\"screenHeight\": mapData.screenHeight,\n\t\t\t\t\t\"screenCountX\": level.screenCountX,\n\t\t\t\t\t\"screenCountY\": level.screenCountY,\n\t\t\t\t\t\"objects\": objects,\n\t\t\t\t\t\"mapWidth\": map[ 0 ].length,\n\t\t\t\t\t\"mapHeight\": map.length,\n\t\t\t\t\t\"mapData\": map,\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\t);\n\n\t// Set game name.\n\t// Some settings use this, for things like local storage keys.\n\tif ( mapper.settings.gameName ) {\n\t\tb8.CONFIG.NAME = mapper.settings.gameName;\n\t}\n\n\t// Setup player.\n\tmapper.player = mapper.types.player.spawn();\n\n\tmapper.lastPosition = {\n\t\tcol: 0,\n\t\trow: 0,\n\t\tmap: 0\n\t};\n\n\t// This sets the map and then loads the objects.\n\tmapper.setCurrentMap( 0 );\n\n\t// Count all coin objects.\n\t// Loop through all levels and count coins\n\tlet coinCount = 0;\n\tfor ( const level of mapper.maps ) {\n\t\tcoinCount += level.objects.filter( obj => obj.type === 'coin' ).length;\n\t}\n\tb8.data.totalCoins = coinCount;\n\n\t// Add systems.\n\n\t// AI First so it can set intents before movement.\n\tb8.ECS.addSystem( 'ai', mapper.systems.ai );\n\n\t// Everything else.\n\tb8.ECS.addSystem( 'action-cooldown', mapper.systems.actionCooldown );\n\tb8.ECS.addSystem( 'characterAnimation', mapper.systems.characterAnimation );\n\tb8.ECS.addSystem( 'pathFollower', mapper.systems.pathFollower );\n\tb8.ECS.addSystem( 'sprite', mapper.systems.sprite );\n\tb8.ECS.addSystem( 'pickup', mapper.systems.pickup );\n\tb8.ECS.addSystem( 'vfx', mapper.systems.vfx );\n\tb8.ECS.addSystem( 'health', mapper.systems.health );\n\tb8.ECS.addSystem( 'bomb', mapper.systems.bomb );\n\tb8.ECS.addSystem( 'fire', mapper.systems.fire );\n\tb8.ECS.addSystem( 'fireSmall', mapper.systems.fireSmall );\n\tb8.ECS.addSystem( 'flammable', mapper.systems.flammable );\n\n\t// Play music.\n\tif ( mapper.settings.bgm ) b8.Music.play( mapper.settings.bgm );\n\n\t// Validate map data.\n\tif (\n\t\tmapper.settings.splash &&\n\t\tmapper.settings.splash.length > 10 &&\n\t\tb8.Tilemap.validateTilemap( mapper.settings.splash )\n\t) {\n\n\t\tmapper.bg.splash = b8.Tilemap.load( mapper.settings.splash );\n\n\t}\n\n};\n\n\n/**\n * Upgrade map data from version 1 to version 2.\n *\n * @param {Object} mapData - The map data object in version 1 format.\n * @returns {Object} The upgraded map data object in version 2 format.\n */\nmapper.upgradeMapDataV1toV2 = function( mapData ) {\n\n\tconst level = {\n\t\tmapData: [ ...mapData.map ],\n\t\tobjects: [ ...mapData.objects ],\n\t\tscreenCountX: mapData.screenCountX,\n\t\tscreenCountY: mapData.screenCountY,\n\t};\n\n\t// Create a levels object.\n\tmapData.levels = [ level ];\n\n\t// Update version.\n\tmapData.version = 2;\n\n\t// Unset old properties.\n\tdelete mapData.map;\n\tdelete mapData.objects;\n\tdelete mapData.screenCountX;\n\tdelete mapData.screenCountY;\n\n\treturn mapData;\n\n};\n\n\n/**\n * Set the current active map by name.\n *\n * @param {string} mapName - The name of the map to set as current.\n * @returns {void}\n */\nmapper.setCurrentMap = function( mapId, forceLoad = false ) {\n\n\tb8.Utilities.checkInt( 'mapId', mapId );\n\n\tif ( mapId < 0 || mapId >= mapper.maps.length ) {\n\t\tb8.Utilities.fatal( `Map ID \"${mapId}\" is out of bounds.` );\n\t\treturn;\n\t}\n\n\t// Check if already on this map.\n\tif ( mapId === mapper.currentMapId && !forceLoad ) return;\n\n\t// Set current map id.\n\tmapper.currentMapId = mapId;\n\n\tlet currentMap = mapper.maps[ mapId ];\n\n\t// Add objects.\n\tif ( !currentMap.objects ) currentMap.objects = [];\n\n\t// Delete all ecs entities except the player.\n\tconst allEntities = b8.ECS.getAllEntities();\n\tfor ( const entityId of allEntities ) {\n\n\t\tconst typeComp = b8.ECS.getComponent( entityId, 'Type' );\n\t\tif ( typeComp?.name === 'player' ) continue;\n\t\tb8.ECS.removeEntity( entityId );\n\n\t}\n\n\t// Spawn all objects for the current map.\n\tfor ( const obj of currentMap.objects ) {\n\n\t\tconst handler = mapper.types[ obj.type ];\n\t\tif ( handler?.spawn ) handler.spawn( obj.x, obj.y, obj.props );\n\n\t}\n\n\t// Delete any start objects from the current map.\n\t// It's no longer needed.\n\tmapper.maps[ mapper.currentMapId ].objects = mapper.maps[ mapper.currentMapId ].objects.filter(\n\t\tobj => obj.type !== 'start'\n\t);\n\n};\n\nmapper.menu = {\n\n\t/**\n\t * Get the instructions text.\n\t *\n\t * @returns {string} The instructions text.\n\t */\n\tgetInstructions: function() {\n\n\t\tif ( mapper.hasInstructions() ) {\n\t\t\treturn mapper.settings.instructions;\n\t\t}\n\t\treturn '';\n\n\t},\n\n\n\t/**\n\t * Check if there are instructions available.\n\t *\n\t * @returns {boolean} True if instructions are available, false otherwise.\n\t */\n\thasInstructions: function() {\n\n\t\treturn !!mapper.settings.instructions;\n\n\t},\n\n\n\t/**\n\t * Get the credits text.\n\t *\n\t * @returns {string} The credits text.\n\t */\n\tgetCredits: function() {\n\n\t\tif ( mapper.hasCredits() ) {\n\t\t\treturn mapper.settings.credits;\n\t\t}\n\n\t\treturn '';\n\n\t},\n\n\n\t/**\n\t * Check if there are credits available.\n\t *\n\t * @returns {boolean} True if credits are available, false otherwise.\n\t */\n\thasCredits: function() {\n\n\t\treturn !!mapper.settings.credits;\n\n\t},\n\n\n\t/**\n\t * Draw the splash screen.\n\t *\n\t * @returns {void}\n\t */\n\tdrawSplash: function() {\n\n\t\tif ( mapper.bg.splash ) {\n\t\t\tb8.Tilemap.draw( mapper.bg.splash );\n\n\t\t\t// b8 Logo\n\t\t\tb8.locate( b8.CONFIG.SCREEN_COLS - 1, b8.CONFIG.SCREEN_ROWS - 1 );\n\t\t\tb8.color( 15, 0 );\n\t\t\tb8.printChar( 88 );\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Check if there is a splash screen available.\n\t *\n\t * @returns {boolean} True if a splash screen is available, false otherwise.\n\t */\n\thasSplash: function() {\n\n\t\treturn !!mapper.bg.splash;\n\n\t},\n\n};\n// Namespace for shared data + helpers\nmapper.pathFollower = {\n\n\tDIRS: {\n\t\tU: { dx: 0, dy: -1 },\n\t\tD: { dx: 0, dy: 1 },\n\t\tL: { dx: -1, dy: 0 },\n\t\tR: { dx: 1, dy: 0 },\n\t\tFU: { dx: 0, dy: -1 },\n\t\tFD: { dx: 0, dy: 1 },\n\t\tFL: { dx: -1, dy: 0 },\n\t\tFR: { dx: 1, dy: 0 },\n\t},\n\n\tVEC_TO_DIR: null,\n\n\tanimationMap: {\n\t\tU: \"move-up\",\n\t\tD: \"move-down\",\n\t\tL: \"move-left\",\n\t\tR: \"move-right\",\n\t\tFU: \"idle-up\",\n\t\tFD: \"idle-down\",\n\t\tFL: \"idle-left\",\n\t\tFR: \"idle-right\",\n\t},\n\n\tanimationInverse: {\n\t\tU: \"D\",\n\t\tD: \"U\",\n\t\tL: \"R\",\n\t\tR: \"L\",\n\t\tFU: \"FD\",\n\t\tFD: \"FU\",\n\t\tFL: \"FR\",\n\t\tFR: \"FL\",\n\t},\n\n\n\t/**\n\t * Initialize the path follower module.\n\t *\n\t * @returns {void}\n\t */\n\tinit: function() {\n\n\t\tmapper.pathFollower.VEC_TO_DIR = Object.fromEntries(\n\t\t\tObject.entries( mapper.pathFollower.DIRS )\n\t\t\t\t.map( ( [ dir, v ] ) => [ `${v.dx},${v.dy}`, dir ] )\n\t\t);\n\n\t\tconsole.log( mapper.pathFollower.VEC_TO_DIR );\n\n\t},\n\n\n\t/**\n\t * Advance the path index based on the current mode.\n\t *\n\t * @param {Object} pf - The PathFollower component.\n\t * @returns {void}\n\t */\n\tadvancePathIndex: function( pf ) {\n\n\t\tconst last = pf.steps.length - 1;\n\n\t\tswitch ( pf.mode ) {\n\t\t\tcase b8.Path.AnimationMode.ONCE:\n\t\t\t\tif ( pf.index < last ) pf.index++;\n\t\t\t\tbreak;\n\n\t\t\tcase b8.Path.AnimationMode.LOOP:\n\t\t\t\tpf.index = ( pf.index + 1 ) % pf.steps.length;\n\t\t\t\tbreak;\n\n\t\t\tcase b8.Path.AnimationMode.PINGPONG:\n\t\t\tdefault:\n\t\t\t\tif ( pf.index === 0 ) pf.dirStep = 1;\n\t\t\t\telse if ( pf.index === last ) pf.dirStep = -1;\n\n\t\t\t\tpf.index += pf.dirStep;\n\t\t\t\tbreak;\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Get the facing direction string from a vector.\n\t *\n\t * @param {Object} vec - The direction vector with `dx` and `dy`.\n\t * @returns {string|undefined} The direction string (e.g., 'U', 'D', 'L', 'R') or undefined if not found.\n\t */\n\tgetFaceDirection: function( vec ) {\n\n\t\treturn mapper.pathFollower.VEC_TO_DIR[ `${vec.dx},${vec.dy}` ];\n\n\t},\n\n};\n\nmapper.pathFollower.init();\n\nmapper.sceneGame = {\n\n\tUI: null,\n\n\tmoveDelay: 0.15,\n\n\n\t/**\n\t * Initialize the game scene.\n\t *\n\t * @returns {void}\n\t */\n\tinit: function() {\n\n\t\tmapper.sceneGame.UI = b8.Tilemap.load( mapper.CONFIG.gameUI );\n\n\t},\n\n\n\t/**\n\t * Update the game scene.\n\t *\n\t * @param {number} dt Delta time in seconds since last frame.\n\t * @returns {void}\n\t */\n\tupdate: function( dt ) {\n\n\t\t// Update systems.\n\t\tmapper.update( dt );\n\n\t\tmapper.sceneGame.moveDelay -= dt;\n\t\tif ( mapper.sceneGame.moveDelay > 0 ) return;\n\n\t\t// Get player components\n\t\tconst loc = b8.ECS.getComponent( mapper.player, 'Loc' );\n\n\t\tlet dx = 0, dy = 0, keyPressed = false;\n\n\t\t// Calculate direction of movement.\n\t\t// Use else if so we can only move in one direction at a time and not jump\n\t\t// over collision walls diagonally.\n\t\tif ( b8.key( \"ArrowUp\" ) ) { dy = -1; keyPressed = true; }\n\t\telse if ( b8.key( \"ArrowDown\" ) ) { dy = 1; keyPressed = true; }\n\t\telse if ( b8.key( \"ArrowLeft\" ) ) { dx = -1; keyPressed = true; }\n\t\telse if ( b8.key( \"ArrowRight\" ) ) { dx = 1; keyPressed = true; }\n\t\tif ( b8.key( \"ButtonA\" ) ) { mapper.doAttack( mapper.player, 'ButtonA' ); keyPressed = true; }\n\t\tif ( b8.key( \"ButtonB\" ) ) { mapper.doAction( mapper.player, 'ButtonB' ); keyPressed = true; }\n\n\t\t// Update move delay when a key is pressed.\n\t\tif ( keyPressed ) mapper.updateMoveDelay();\n\n\t\t// Move player.\n\t\tif ( dx !== 0 || dy !== 0 ) {\n\n\t\t\tlet newCol = loc.col + dx;\n\t\t\tlet newRow = loc.row + dy;\n\n\t\t\tmapper.setPlayerWalkAnimation( mapper.player, dx, dy );\n\n\t\t\t// Now check for regular collision (walls etc).\n\t\t\tif (\n\t\t\t\t!mapper.collision.isWalkable( newCol, newRow ) ||\n\t\t\t\tmapper.doCollision( loc.col, loc.row, newCol, newRow, dx, dy )\n\t\t\t) {\n\t\t\t\tnewCol = loc.col;\n\t\t\t\tnewRow = loc.row;\n\t\t\t}\n\n\t\t\tb8.ECS.setComponent( mapper.player, 'Direction', { dx, dy } );\n\t\t\tb8.ECS.setLoc( mapper.player, newCol, newRow );\n\n\t\t}\n\n\t},\n\n\n\t/**\n\t * Render the game scene.\n\t *\n\t * @returns {void}\n\t */\n\trender: function() {\n\n\t\tb8.cls( 0 );\n\n\t\tb8.locate( mapper.CONFIG.mapOffsetX, mapper.CONFIG.mapOffsetY );\n\t\tmapper.drawScreen();\n\t\tmapper.render( mapper.CONFIG.mapOffsetX, mapper.CONFIG.mapOffsetY );\n\n\t\t// Draw UI background.\n\t\tb8.locate( 0, b8.CONFIG.SCREEN_ROWS - mapper.sceneGame.UI.length );\n\t\tb8.Tilemap.draw( mapper.sceneGame.UI );\n\n\t\t// Draw currency value.\n\t\tb8.locate( 2, b8.CONFIG.SCREEN_ROWS - 2 );\n\t\tb8.color( parseInt( mapper.settings.coinColor ) || 10, 0 );\n\t\tb8.printChar( parseInt( mapper.settings.coin ) || 266 );\n\n\t\tb8.color( 15, 0 );\n\t\tb8.print( ' ' + parseInt( b8.Inventory.getCount( 'coin' ) ).toString().padStart( 4, '0' ) );\n\n\t\t// Draw heart containers.\n\t\tconst health = b8.ECS.getComponent( mapper.player, 'Health' );\n\t\tconst max = health.max;\n\t\tconst hp = Math.floor( health.value );\n\n\t\tfor ( let i = 0; i < Math.floor( max / 2 ); i++ ) {\n\t\t\tconst x = 2 + i;\n\t\t\tconst y = b8.CONFIG.SCREEN_ROWS - 3;\n\t\t\tb8.locate( x, y );\n\t\t\tif ( hp >= ( i * 2 ) + 2 ) {\n\t\t\t\t// Full heart.\n\t\t\t\tb8.color( 8, 0 );\n\t\t\t\tb8.printChar( 415 );\n\t\t\t} else if ( hp === ( i * 2 ) + 1 ) {\n\t\t\t\t// Half heart.\n\t\t\t\tb8.color( 8, 0 );\n\t\t\t\tb8.printChar( 416 );\n\t\t\t} else {\n\t\t\t\t// Empty heart.\n\t\t\t\tb8.color( 6, 0 );\n\t\t\t\tb8.printChar( 417 );\n\t\t\t}\n\t\t}\n\n\t\t// Draw keys.\n\t\tconst keys = b8.Inventory.filter( /^key/ );\n\t\t// Loop through keys and draw them.\n\t\tkeys.forEach(\n\t\t\t( item, index ) => {\n\t\t\t\tconst color = parseInt( item.id.split( '-' )[ 1 ] ) || 15;\n\t\t\t\tb8.locate( 10 + index, b8.CONFIG.SCREEN_ROWS - 2 );\n\t\t\t\tb8.color( color, -1 );\n\t\t\t\tb8.printChar( 255 );\n\t\t\t}\n\t\t);\n\n\t\t// Draw actions.\n\t\t// -------------\n\t\tb8.color( 15, -1 );\n\n\t\t// I add a space before the text to add a gap between the icon and the text.\n\t\t// The gap is a half tile which is harder to add directly.\n\n\t\t// A button.\n\t\tb8.locate( 11, b8.CONFIG.SCREEN_ROWS - 4 );\n\t\tb8.print( ' Hit' );\n\n\t\t// B button.\n\t\tb8.locate( 15, b8.CONFIG.SCREEN_ROWS - 4 );\n\t\tb8.print( mapper.helpers.capitalizeWords( ' ' + mapper.promptAhead( mapper.player, 'ButtonB' ) ) );\n\n\t\treturn;\n\n\t},\n\n};\n// const menuBg = `mB6YGIUBBAAAoIUBBAAAoIUBBAAAoIUDBQQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUSDwQAoIUTDwQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIURAwQAoIURAwQAoIUBBAAAoJgYhREDBACghQEEAACghQEEAACghQEEAACghRgpCgQAoIUBBAAAoIUBBAAAoIUSDwQAoIUBDwQAoIUBDwQAoIUABA8AoIUBDwQAoIUTDwQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUDBQQAoIUBBAAAoIURAwQAoIURAwQAoIUBBAAAoJgYhREDBACghQEEAACghQEEAACghQEEAACghQEKDQCghQEEAACghQAKBACghRgkDwQAoIUYcgQKAKCFGD0ECgCghRigBA8AoIUYPQQKAKCFCwQPAKCFAQoNAKCFAQQAAKCFEg0EAKCFAg0MAKCFEw0EAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCYGIUBBAAAoIUBBAAAoIURAwQAoIURAwQAoIUBCg0AoIUWCgQAoIUABAoAoIUBBAAAoIUYTgQKAKCFGD0ECgCghQMFBACghRgoBAoAoIUBCg0AoIUBCg0AoIUBBAAAoIUACg0AoIUYKQQNAKCFAAoNAKCFGBkNBACghRgZDQQAoIUYGQ0EAKCFGBkNBACghQEEAACghQEEAACgmBiFAQQAAKCFAQQAAKCFEQMEAKCFEQMEAKCFAQoNAKCFAgoJAKCFAQQAAKCFAQQAAKCFGE4ECgCghQEEDQCghQEEAACghQEEAACghQEEAACghQEKDQCghQEEAACghQAKDQCghRgqBA0AoIUACg0AoIUABA0AoIUABA0AoIUABA0AoIUYJQ0EAKCFAQQAAKCFAQQAAKCYGIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBCg0AoIUYKAQKAKCFGGEECgCghQEEAACghRhOBAoAoIUBCg0AoIUACgQAoIUBCg0AoIUBCg0AoIUWBAoAoIUBBAAAoIUYJA0EAKCFGGEFDQCghRglDQQAoIUBBA0AoIUABA0AoIUYgQ0EAKCFAQQAAKCFAwUEAKCFAQQAAKCYGIUBBAAAoIUDBQQAoIUBBAAAoIUBBAAAoIUYKgoEAKCFAQQAAKCFGCkKBACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACgmBiFGDUNBACghRgyDQQAoIUBBAAAoIUBBAAAoIUSDwQAoIURBA8AoIUYTgQKAKCFEQQPAKCFEw8EAKCFAQQAAKCFGE4ECgCghQEEAACghQEKBACghQEEAACghQEKBACghQEKBACghQEEAACghRYKBACghRhQBAoAoIUACgQAoIUABAoAoIUCCgkAoIUCCgkAoIUBBAAAoJgYhRgiBA0AoIUYIQQNAKCFAQQAAKCFEg8EAKCFAQ8EAKCFAQ8EAKCFGE4ECgCghRYKDwCghRhQBAoAoIUTDwQAoIUYTgQKAKCFGBoKBACghQIKCQCghQEEAACghQEKBACghRg9BAoAoIUBBAAAoIUBCgQAoIUYcwQKAKCFAQQKAKCFAQQAAKCFGFAECgCghQEEAACghRIPBACgmBiFAAANAKCFEAwNAKCFGDINBACghRgkDwQAoIUBDwQAoIUYoAQPAKCFGE4ECgCghRhQBAoAoIULBA8AoIULBA8AoIUYTgQKAKCFAgoJAKCFAgoJAKCFAwUEAKCFAQoEAKCFAQQAAKCFAQQAAKCFAQQKAKCFGFAECgCghQEECgCghRIPBACghRhQBAoAoIUBDw0AoIUBDw0AoJgYhQMFDQCghQAADQCghRghBA0AoIUBBAAAoIUBBAAAoIUBBAAAoIUYTgQKAKCFGCgECgCghRhQBAoAoIUBBAAAoIUYTgQKAKCFGBoECgCghQEKBACghQEEAACghQEKBACghQEKBACghQEEAACghQEKBACghRhQBAoAoIUSDwQAoIUYoAQPAKCFGFAECgCghQsEDwCghQsEDwCgmBiFAAANAKCFAwUNAKCFGDIBDQCghQAABACghQAABACghQEEAACghRgqCgQAoIUBBAAAoIUBBAAAoIUBBAAAoIUACgQAoIUBBAAAoIUACgQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUXDwQAoIUBDw0AoIUYoAQPAKCFGLMEDwCghRigBA8AoIULBA8AoIULBA8AoJgYhREBDQCghRgyAQ0AoIUAAA0AoIUYMg0EAKCFAAAEAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAwUEAKCFAQQAAKCFAQQAAKCFAQQAAKCFEQMEAKCFEQMEAKCFEQMEAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCYGIUDBQ0AoIUAAA0AoIUAAA0AoIUYIQQNAKCFAAAEAKCFAQQAAKCFEQMEAKCFEQMEAKCFEQMEAKCFAAMEAKCFAAAEAKCFAAAEAKCFEQMEAKCFAAAEAKCFAAAEAKCFAAAEAKCFEQMEAKCFEQMEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAQQAAKCYGIUDBQ0AoIUBDQQAoIUJDQUAoIUYMgENAKCFAAAEAKCFAAAEAKCFEQMEAKCFEQMEAKCFEQMEAKCFAQQAAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFGEsHBACghRhLBwQAoIUAAAQAoIUDBQQAoIURAwQAoJgYhQAADQCghQAADQCghQAADQCghQAADQCghRgyDQQAoIUAAAQAoIUBBAAAoIUBBAAAoIUBBAAAoIUACAQAoIUYNAgEAKCFAAAEAKCFGHcDBACghQAABACghQAABACghQAABACghQAABACghQAABACghQAABACghRkBTQIFAKCFGQFNAgUAoIUYMwgEAKCFAAAEAKCFEQMEAKCYGIURAQ0AoIUQDA0AoIUAAA0AoIUYMgENAKCFGCEEDQCghQMFBACghRg1BQQAoIUYMgUEAKCFAQQAAKCFAAgEAKCFGBkHCACghRgZBwgAoIUYGQcIAKCFGBkHCACghRgZBwgAoIUYGQcIAKCFGBkHCACghRgZBwgAoIUYGQcIAKCFGQFOAgUAoIUZAU0CBQCghRgZBwgAoIUACAQAoIUYNQUEAKCYGIUDBQ0AoIUDBQ0AoIUAAA0AoIUQDA0AoIUYIQQNAKCFAAAEAKCFGCIEBQCghRghBAUAoIUBBAAAoIUDBQQAoIURBwgAoIURBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBTQIFAKCFGQFNAgUAoIUZAQgHCACghRgyBQQAoIUYIgQFAKCYGIUAAA0AoIUAAA0AoIUAAA0AoIUAAA0AoIUAAA0AoIUYLAQFAKCFAAIFAKCFGCkBBQCghRgyBQQAoIUYGgEEAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIURBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAgHAKCFGQEICAcAoIUZAQgHCACghQACBQCghRgaAQUAoJgYhQMFDQCghQMFDQCghQAADQCghQAADQCghRAMDQCghRgoDQUAoIUYNQEFAKCFAAIBAKCFGCwFAQCghQACAQCghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghREHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUYNQEFAKCFAAIBAKCYGIURAQ0AoIUDBQ0AoIUAAA0AoIUYMgENAKCFEAwNAKCFAAANAKCFAAIBAKCFAAIBAKCFAAIBAKCFGFkFAQCghRkBTQUBAKCFGQFNBQEAoIUZAU0FAQCghRkBTgUBAKCFGQFPBQEAoIUZAU0FAQCghRkBTQUBAKCFGQFNBQEAoIUZAU0FAQCghRkBTgUBAKCFGQFNBQEAoIUZAU0FAQCghRhXBQEAoIUAAgEAoJgYhQMFDQCghQAADQCghQMFDQCghQAADQCghQAADQCghRgyAQ0AoIUYMg0BAKCFAAIBAKCFAAIBAKCFGFkCAQCghRkBTQIFAKCFGQFOAgUAoIUZAU0CBQCghRkBTQIFAKCFGHIBDQCghRg9AQ0AoIUYPQENAKCFGHMBDQCghRkBTQIFAKCFGQFNAgUAoIUZAU0CBQCghRkBTgIFAKCFGFcCAQCghQACAQCgmBiFEQENAKCFAwUNAKCFAAANAKCFAAANAKCFCQ0FAKCFAAANAKCFGCEBDQCghQACAQCghQACAQCghRhZAgEAoIUZAU0CBQCghQEABQCghRkBTQIFAKCFGQFNAgUAoIUYTgENAKCFAQAFAKCFAQANAKCFGFAFDQCghRkBTQIFAKCFAQAFAKCFAQAEAKCFGQFNAgUAoIUYVwIBAKCFAAIBAKCYGIUAAA0AoIUAAA0AoIUAAA0AoIUDBQ0AoIUAAA0AoIUYMgENAKCFAAANAKCFGQEgDA0AoIUZATIMDQCghRkBMgwNAKCFGQFNAgUAoIUYKwABAKCFGQFNAgUAoIUZAU0CBQCghRhOAQ0AoIUYKwABAKCFAQEFAKCFGFAFDQCghRkBTQIFAKCFGCsAAQCghQEBAQCghRkBTQIFAKCFGQEgDA0AoIUZASEMDQCgmBiFGDIGDQCghQMFDQCghRgyBg0AoIUYNAwNAKCFGDQMDQCghQAADQCghRgyDQwAoIUZATMNDACghRENDACghRENDACghRkBTQIFAKCFGBkCAwCghRkBTQIFAKCFGQFOAgUAoIUYTgENAKCFGD0MDQCghRg9DA0AoIUYUAUNAKCFGQFNAgUAoIUYGQIDAKCFGDcDDwCghRg3Aw8AoIUYNwMPAKCFEQ0MAKCYGIULBgcAoIULBgcAoIUOBgcAoIUYVwcMAKCFAAAMAKCFGQEgDQwAoIUZASUNDACghQAADACghRkBJQ0MAKCFGFMCDACghRkBTgIFAKCFGQFNAgUAoIUZAU8CBQCghRkBTQIFAKCFGIQFDQCghQsNBQCghRhhBQ0AoIUYhQUNAKCFGQFNAgUAoIUZAU0CBQCghRg3Aw8AoIUYNwMPAKCFGDcDDwCghRkBNw0MAKCYGIURBgcAoIUY5QYHAKCFGQEaBgcAoIUYVwcMAKCFAQwAAKCFEQ0MAKCFAQwAAKCFGQElDQwAoIUBDAAAoIUYUw0MAKCFAQ0MAKCFGQEyDA0AoIUBDQwAoIUZATcMDQCghQENDACghQENDACghRkBMgwNAKCFAQ0MAKCFGQEzDA0AoIUBDQwAoIUBDQwAoIUYPQUPAKCFAQwAAKCFGQElDQwAoJgYhRiUBw0AoIUYlAcNAKCFGJQHDQCghRgoDQwAoIUZASUNDACghQEMAACghRkBJQ0MAKCFGQElDQwAoIURDQwAoIUYVg0MAKCFGQE3DA0AoIUZATMMDQCghQENDACghRcFDQCghQEFDACghRglBQ0AoIUBDQwAoIUZATIMDQCghRkBNwwNAKCFAQ0MAKCFGQEzDA0AoIUBDQwAoIUZATUNDACghRENDACgmBiFAwENAKCFGQEzDA0AoIUZASUMDQCghRkBNwwNAKCFGCgNDACghRkBJQ0MAKCFAQwAAKCFGQEgDQwAoIUZATcNDACghRkBJQ0MAKCFAw0MAKCFAw0MAKCFGQElDQwAoIUDDQwAoIUZATcNDACghRcCDACghQMNAgCghRMCDACghRkBMw0MAKCFGFYNDACghRkBNwwNAKCFGQEyDA0AoIUZATMMDQCghRkBJQ0MAKCYGIUYWAwNAKCFGQElDA0AoIUZASUMDQCghQAMDQCghRkBMwwNAKCFGQEzDA0AoIUZATcMDQCghRgoDQwAoIUZASUNDACghQEMAACghRkBNw0MAKCFAQwAAKCFGQEzDQwAoIUZATcNDACghRICDACghRgYAgwAoIUZATMNDACghRkBJQ0MAKCFAQwAAKCFGQElDQwAoIUZASUNDACghRkBJQ0MAKCFGQElDQwAoIUZASUNDACg`;\n\nmapper.sceneGameOver = {\n\n\t/**\n\t * Initialize the menu scene.\n\t *\n\t * @returns {void}\n\t */\n\tinit: function() {\n\n\t\tmapper.sceneGameOver.main();\n\n\t},\n\n\n\t/**\n\t * Draw the main menu.\n\t *\n\t * @returns {void}\n\t */\n\tmain: async () => {\n\n\t\tb8.cls( 6 );\n\n\t\tb8.locate( 0, 5 );\n\t\tb8.color( 10, 6 );\n\n\t\tb8.printCentered( \"GAME OVER\\n\\n\" );\n\n\t\tlet menuChoices = [ \"Continue\", \"Main Menu\" ];\n\n\t\tlet choice = await b8.Async.menu(\n\t\t\tmenuChoices,\n\t\t\t{\n\t\t\t\tborder: false,\n\t\t\t\tpadding: 0,\n\t\t\t\tcenterH: true,\n\t\t\t}\n\t\t);\n\n\t\tconst selected = menuChoices[ choice ];\n\n\t\t// Start a new game.\n\t\tif ( 'Continue' === selected ) {\n\t\t\tmapper.continue();\n\t\t\tb8.Scene.set( 'game' );\n\t\t\treturn;\n\t\t}\n\n\t\t// Show instructions.\n\t\tif ( 'Main Menu' === selected ) {\n\t\t\tb8.Scene.set( 'menu' );\n\t\t\treturn;\n\t\t}\n\n\t\tsetTimeout( mapper.sceneGameOver.main, 10 );\n\n\t}\n\n};\n\n// const menuBg = `mB6YGIUBBAAAoIUBBAAAoIUBBAAAoIUDBQQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUSDwQAoIUTDwQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIURAwQAoIURAwQAoIUBBAAAoJgYhREDBACghQEEAACghQEEAACghQEEAACghRgpCgQAoIUBBAAAoIUBBAAAoIUSDwQAoIUBDwQAoIUBDwQAoIUABA8AoIUBDwQAoIUTDwQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUDBQQAoIUBBAAAoIURAwQAoIURAwQAoIUBBAAAoJgYhREDBACghQEEAACghQEEAACghQEEAACghQEKDQCghQEEAACghQAKBACghRgkDwQAoIUYcgQKAKCFGD0ECgCghRigBA8AoIUYPQQKAKCFCwQPAKCFAQoNAKCFAQQAAKCFEg0EAKCFAg0MAKCFEw0EAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCYGIUBBAAAoIUBBAAAoIURAwQAoIURAwQAoIUBCg0AoIUWCgQAoIUABAoAoIUBBAAAoIUYTgQKAKCFGD0ECgCghQMFBACghRgoBAoAoIUBCg0AoIUBCg0AoIUBBAAAoIUACg0AoIUYKQQNAKCFAAoNAKCFGBkNBACghRgZDQQAoIUYGQ0EAKCFGBkNBACghQEEAACghQEEAACgmBiFAQQAAKCFAQQAAKCFEQMEAKCFEQMEAKCFAQoNAKCFAgoJAKCFAQQAAKCFAQQAAKCFGE4ECgCghQEEDQCghQEEAACghQEEAACghQEEAACghQEKDQCghQEEAACghQAKDQCghRgqBA0AoIUACg0AoIUABA0AoIUABA0AoIUABA0AoIUYJQ0EAKCFAQQAAKCFAQQAAKCYGIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUBCg0AoIUYKAQKAKCFGGEECgCghQEEAACghRhOBAoAoIUBCg0AoIUACgQAoIUBCg0AoIUBCg0AoIUWBAoAoIUBBAAAoIUYJA0EAKCFGGEFDQCghRglDQQAoIUBBA0AoIUABA0AoIUYgQ0EAKCFAQQAAKCFAwUEAKCFAQQAAKCYGIUBBAAAoIUDBQQAoIUBBAAAoIUBBAAAoIUYKgoEAKCFAQQAAKCFGCkKBACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACghQEEAACgmBiFGDUNBACghRgyDQQAoIUBBAAAoIUBBAAAoIUSDwQAoIURBA8AoIUYTgQKAKCFEQQPAKCFEw8EAKCFAQQAAKCFGE4ECgCghQEEAACghQEKBACghQEEAACghQEKBACghQEKBACghQEEAACghRYKBACghRhQBAoAoIUACgQAoIUABAoAoIUCCgkAoIUCCgkAoIUBBAAAoJgYhRgiBA0AoIUYIQQNAKCFAQQAAKCFEg8EAKCFAQ8EAKCFAQ8EAKCFGE4ECgCghRYKDwCghRhQBAoAoIUTDwQAoIUYTgQKAKCFGBoKBACghQIKCQCghQEEAACghQEKBACghRg9BAoAoIUBBAAAoIUBCgQAoIUYcwQKAKCFAQQKAKCFAQQAAKCFGFAECgCghQEEAACghRIPBACgmBiFAAANAKCFEAwNAKCFGDINBACghRgkDwQAoIUBDwQAoIUYoAQPAKCFGE4ECgCghRhQBAoAoIULBA8AoIULBA8AoIUYTgQKAKCFAgoJAKCFAgoJAKCFAwUEAKCFAQoEAKCFAQQAAKCFAQQAAKCFAQQKAKCFGFAECgCghQEECgCghRIPBACghRhQBAoAoIUBDw0AoIUBDw0AoJgYhQMFDQCghQAADQCghRghBA0AoIUBBAAAoIUBBAAAoIUBBAAAoIUYTgQKAKCFGCgECgCghRhQBAoAoIUBBAAAoIUYTgQKAKCFGBoECgCghQEKBACghQEEAACghQEKBACghQEKBACghQEEAACghQEKBACghRhQBAoAoIUSDwQAoIUYoAQPAKCFGFAECgCghQsEDwCghQsEDwCgmBiFAAANAKCFAwUNAKCFGDIBDQCghQAABACghQAABACghQEEAACghRgqCgQAoIUBBAAAoIUBBAAAoIUBBAAAoIUACgQAoIUBBAAAoIUACgQAoIUBBAAAoIUBBAAAoIUBBAAAoIUBBAAAoIUXDwQAoIUBDw0AoIUYoAQPAKCFGLMEDwCghRigBA8AoIULBA8AoIULBA8AoJgYhREBDQCghRgyAQ0AoIUAAA0AoIUYMg0EAKCFAAAEAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAwUEAKCFAQQAAKCFAQQAAKCFAQQAAKCFEQMEAKCFEQMEAKCFEQMEAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCFAQQAAKCYGIUDBQ0AoIUAAA0AoIUAAA0AoIUYIQQNAKCFAAAEAKCFAQQAAKCFEQMEAKCFEQMEAKCFEQMEAKCFAAMEAKCFAAAEAKCFAAAEAKCFEQMEAKCFAAAEAKCFAAAEAKCFAAAEAKCFEQMEAKCFEQMEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAQQAAKCYGIUDBQ0AoIUBDQQAoIUJDQUAoIUYMgENAKCFAAAEAKCFAAAEAKCFEQMEAKCFEQMEAKCFEQMEAKCFAQQAAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFAAAEAKCFGEsHBACghRhLBwQAoIUAAAQAoIUDBQQAoIURAwQAoJgYhQAADQCghQAADQCghQAADQCghQAADQCghRgyDQQAoIUAAAQAoIUBBAAAoIUBBAAAoIUBBAAAoIUACAQAoIUYNAgEAKCFAAAEAKCFGHcDBACghQAABACghQAABACghQAABACghQAABACghQAABACghQAABACghRkBTQIFAKCFGQFNAgUAoIUYMwgEAKCFAAAEAKCFEQMEAKCYGIURAQ0AoIUQDA0AoIUAAA0AoIUYMgENAKCFGCEEDQCghQMFBACghRg1BQQAoIUYMgUEAKCFAQQAAKCFAAgEAKCFGBkHCACghRgZBwgAoIUYGQcIAKCFGBkHCACghRgZBwgAoIUYGQcIAKCFGBkHCACghRgZBwgAoIUYGQcIAKCFGQFOAgUAoIUZAU0CBQCghRgZBwgAoIUACAQAoIUYNQUEAKCYGIUDBQ0AoIUDBQ0AoIUAAA0AoIUQDA0AoIUYIQQNAKCFAAAEAKCFGCIEBQCghRghBAUAoIUBBAAAoIUDBQQAoIURBwgAoIURBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBTQIFAKCFGQFNAgUAoIUZAQgHCACghRgyBQQAoIUYIgQFAKCYGIUAAA0AoIUAAA0AoIUAAA0AoIUAAA0AoIUAAA0AoIUYLAQFAKCFAAIFAKCFGCkBBQCghRgyBQQAoIUYGgEEAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIURBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAgHAKCFGQEICAcAoIUZAQgHCACghQACBQCghRgaAQUAoJgYhQMFDQCghQMFDQCghQAADQCghQAADQCghRAMDQCghRgoDQUAoIUYNQEFAKCFAAIBAKCFGCwFAQCghQACAQCghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghREHCACghRkBCAcIAKCFGQEIBwgAoIUZAQgHCACghRkBCAcIAKCFGQEIBwgAoIUYNQEFAKCFAAIBAKCYGIURAQ0AoIUDBQ0AoIUAAA0AoIUYMgENAKCFEAwNAKCFAAANAKCFAAIBAKCFAAIBAKCFAAIBAKCFGFkFAQCghRkBTQUBAKCFGQFNBQEAoIUZAU0FAQCghRkBTgUBAKCFGQFPBQEAoIUZAU0FAQCghRkBTQUBAKCFGQFNBQEAoIUZAU0FAQCghRkBTgUBAKCFGQFNBQEAoIUZAU0FAQCghRhXBQEAoIUAAgEAoJgYhQMFDQCghQAADQCghQMFDQCghQAADQCghQAADQCghRgyAQ0AoIUYMg0BAKCFAAIBAKCFAAIBAKCFGFkCAQCghRkBTQIFAKCFGQFOAgUAoIUZAU0CBQCghRkBTQIFAKCFGHIBDQCghRg9AQ0AoIUYPQENAKCFGHMBDQCghRkBTQIFAKCFGQFNAgUAoIUZAU0CBQCghRkBTgIFAKCFGFcCAQCghQACAQCgmBiFEQENAKCFAwUNAKCFAAANAKCFAAANAKCFCQ0FAKCFAAANAKCFGCEBDQCghQACAQCghQACAQCghRhZAgEAoIUZAU0CBQCghQEABQCghRkBTQIFAKCFGQFNAgUAoIUYTgENAKCFAQAFAKCFAQANAKCFGFAFDQCghRkBTQIFAKCFAQAFAKCFAQAEAKCFGQFNAgUAoIUYVwIBAKCFAAIBAKCYGIUAAA0AoIUAAA0AoIUAAA0AoIUDBQ0AoIUAAA0AoIUYMgENAKCFAAANAKCFGQEgDA0AoIUZATIMDQCghRkBMgwNAKCFGQFNAgUAoIUYKwABAKCFGQFNAgUAoIUZAU0CBQCghRhOAQ0AoIUYKwABAKCFAQEFAKCFGFAFDQCghRkBTQIFAKCFGCsAAQCghQEBAQCghRkBTQIFAKCFGQEgDA0AoIUZASEMDQCgmBiFGDIGDQCghQMFDQCghRgyBg0AoIUYNAwNAKCFGDQMDQCghQAADQCghRgyDQwAoIUZATMNDACghRENDACghRENDACghRkBTQIFAKCFGBkCAwCghRkBTQIFAKCFGQFOAgUAoIUYTgENAKCFGD0MDQCghRg9DA0AoIUYUAUNAKCFGQFNAgUAoIUYGQIDAKCFGDcDDwCghRg3Aw8AoIUYNwMPAKCFEQ0MAKCYGIULBgcAoIULBgcAoIUOBgcAoIUYVwcMAKCFAAAMAKCFGQEgDQwAoIUZASUNDACghQAADACghRkBJQ0MAKCFGFMCDACghRkBTgIFAKCFGQFNAgUAoIUZAU8CBQCghRkBTQIFAKCFGIQFDQCghQsNBQCghRhhBQ0AoIUYhQUNAKCFGQFNAgUAoIUZAU0CBQCghRg3Aw8AoIUYNwMPAKCFGDcDDwCghRkBNw0MAKCYGIURBgcAoIUY5QYHAKCFGQEaBgcAoIUYVwcMAKCFAQwAAKCFEQ0MAKCFAQwAAKCFGQElDQwAoIUBDAAAoIUYUw0MAKCFAQ0MAKCFGQEyDA0AoIUBDQwAoIUZATcMDQCghQENDACghQENDACghRkBMgwNAKCFAQ0MAKCFGQEzDA0AoIUBDQwAoIUBDQwAoIUYPQUPAKCFAQwAAKCFGQElDQwAoJgYhRiUBw0AoIUYlAcNAKCFGJQHDQCghRgoDQwAoIUZASUNDACghQEMAACghRkBJQ0MAKCFGQElDQwAoIURDQwAoIUYVg0MAKCFGQE3DA0AoIUZATMMDQCghQENDACghRcFDQCghQEFDACghRglBQ0AoIUBDQwAoIUZATIMDQCghRkBNwwNAKCFAQ0MAKCFGQEzDA0AoIUBDQwAoIUZATUNDACghRENDACgmBiFAwENAKCFGQEzDA0AoIUZASUMDQCghRkBNwwNAKCFGCgNDACghRkBJQ0MAKCFAQwAAKCFGQEgDQwAoIUZATcNDACghRkBJQ0MAKCFAw0MAKCFAw0MAKCFGQElDQwAoIUDDQwAoIUZATcNDACghRcCDACghQMNAgCghRMCDACghRkBMw0MAKCFGFYNDACghRkBNwwNAKCFGQEyDA0AoIUZATMMDQCghRkBJQ0MAKCYGIUYWAwNAKCFGQElDA0AoIUZASUMDQCghQAMDQCghRkBMwwNAKCFGQEzDA0AoIUZATcMDQCghRgoDQwAoIUZASUNDACghQEMAACghRkBNw0MAKCFAQwAAKCFGQEzDQwAoIUZATcNDACghRICDACghRgYAgwAoIUZATMNDACghRkBJQ0MAKCFAQwAAKCFGQElDQwAoIUZASUNDACghRkBJQ0MAKCFGQElDQwAoIUZASUNDACg`;\n\nmapper.sceneMenu = {\n\n\t/**\n\t * Initialize the menu scene.\n\t *\n\t * @returns {void}\n\t */\n\tinit: function() {\n\n\t\t// No splash screen so skip the menu.\n\t\tif ( !mapper.menu.hasSplash() ) {\n\t\t\tb8.Scene.set( 'game' );\n\t\t\treturn;\n\t\t}\n\n\t\tmapper.sceneMenu.main();\n\n\t},\n\n\n\t/**\n\t * Draw the main menu.\n\t *\n\t * @returns {void}\n\t */\n\tmain: async () => {\n\n\t\tb8.locate( 0, 0 );\n\t\tmapper.menu.drawSplash();\n\n\t\tb8.locate( 5, 18 );\n\t\tb8.color( 0, 10 );\n\n\t\tlet menuChoices = [ \"Start Game\", ];\n\t\tif ( mapper.menu.hasInstructions() ) menuChoices.push( \"Instructions\" );\n\t\tif ( mapper.menu.hasCredits() ) menuChoices.push( \"Credits\" );\n\n\t\tlet choice = await b8.Async.menu(\n\t\t\tmenuChoices,\n\t\t\t{\n\t\t\t\tborder: false,\n\t\t\t\tpadding: 0,\n\t\t\t\tcenterH: true,\n\t\t\t}\n\t\t);\n\n\t\tconst selected = menuChoices[ choice ];\n\n\t\t// Start a new game.\n\t\tif ( 'Start Game' === selected ) {\n\t\t\tmapper.reset();\n\t\t\tb8.Scene.set( 'game' );\n\t\t\treturn;\n\t\t}\n\n\t\t// Show instructions.\n\t\tif ( 'Instructions' === selected ) {\n\t\t\tb8.locate( 2, 2 );\n\t\t\tb8.color( 15, 13 );\n\t\t\tconst instructions = b8.wrapText(\n\t\t\t\tmapper.menu.getInstructions(),\n\t\t\t\tb8.CONFIG.SCREEN_COLS - 6\n\t\t\t);\n\t\t\tawait b8.Async.dialog( instructions, [ \"OK\" ] );\n\t\t}\n\n\t\t// Show credits.\n\t\tif ( 'Credits' === selected ) {\n\t\t\tb8.locate( 2, 2 );\n\t\t\tb8.color( 15, 13 );\n\t\t\tconst credits = b8.wrapText(\n\t\t\t\tmapper.menu.getCredits(),\n\t\t\t\tb8.CONFIG.SCREEN_COLS - 6\n\t\t\t);\n\t\t\tawait b8.Async.dialog( credits, [ \"OK\" ] );\n\t\t}\n\n\t\tsetTimeout( mapper.sceneMenu.main, 10 );\n\n\t}\n\n};\n\nmapper.systems.actionCooldown = function( dt ) {\n\n\tconst ids = b8.ECS.query( 'ActionCooldown' );\n\n\tfor ( const id of ids ) {\n\n\t\tconst ac = b8.ECS.getComponent( id, 'ActionCooldown' );\n\n\t\tac.time -= dt;\n\t\tif ( ac.time < 0 ) ac.time = 0;\n\n\t}\n\n};\nmapper.ai.updateTimer = 0;\n\nmapper.systems.ai = function( dt ) {\n\n\tmapper.ai.updateTimer += dt;\n\tif ( mapper.ai.updateTimer < mapper.CONFIG.aiUpdateDelay ) return;\n\tmapper.ai.updateTimer = 0;\n\n\tconst ids = b8.ECS.query( 'AI', 'Loc' );\n\n\t// Loop through all AI entities.\n\tfor ( const id of ids ) {\n\n\t\tconst mode = mapper.ai.think( id );\n\t\tconst ai = b8.ECS.getComponent( id, 'AI' );\n\n\t\t// If the AI mode has changed, update it.\n\t\tif ( mode !== ai.mode ) {\n\t\t\tai.mode = mode;\n\t\t\tb8.ECS.setComponent( id, 'AI', ai );\n\t\t}\n\n\t\t// Act based on current mode.\n\t\tconst directions = [ 'U', 'D', 'L', 'R' ];\n\t\tconst Loc = b8.ECS.getComponent( id, 'Loc' );\n\n\t\t/**\n\t\t * WANDER\n\t\t * Pick a random direction and distance to move.\n\t\t */\n\t\tif ( mapper.ai.MODE.WANDER === mode ) {\n\n\t\t\tconst direction = b8.Random.pick( directions );\n\t\t\tconst distance = b8.Random.int( 2, 8 );\n\t\t\tconst pauseDuration = b8.Random.int( 8, 24 );\n\n\t\t\t// Path pattern, move in chosen direction for distance, then pause for pauseDuration.\n\t\t\tconst pathCode = `${direction}${distance}P${pauseDuration}`;\n\n\t\t\tconst steps = b8.Path.parseCode(\n\t\t\t\tpathCode,\n\t\t\t\tLoc.col,\n\t\t\t\tLoc.row,\n\t\t\t\tdirection\n\t\t\t);\n\n\t\t\tmapper.types.enemy.setPath( id, steps, b8.Path.AnimationMode.ONCE );\n\n\t\t}\n\n\n\t\t/**\n\t\t * PATROL\n\t\t * Follow predefined path (set in editor).\n\t\t */\n\t\tif ( mapper.ai.MODE.PATROL === mode ) {\n\n\t\t\tconst pf = b8.ECS.getComponent( id, 'PathFollower' );\n\n\t\t\t// Already following a path so return.\n\t\t\tif ( pf?.steps && pf.steps.length > 0 ) continue;\n\n\t\t\tconst ai = b8.ECS.getComponent( id, 'AI' );\n\n\t\t\t// Follow default default path.\n\t\t\tif ( ai.path && ai.path.length > 0 ) {\n\n\t\t\t\tconst Loc = b8.ECS.getComponent( id, 'Loc' );\n\n\t\t\t\t// If not on path set path to nearest point.\n\t\t\t\tconst nearestPathIndex = mapper.ai.nearestPathIndex( Loc, ai.path );\n\t\t\t\tconst nearestPathTile = ai.path[ nearestPathIndex ];\n\n\t\t\t\t// If the player is not on the path, move to the nearest path tile first.\n\t\t\t\tif (\n\t\t\t\t\tnearestPathTile.col === Loc.col &&\n\t\t\t\t\tnearestPathTile.row === Loc.row\n\t\t\t\t) {\n\t\t\t\t\t// Already on path, start from nearest index.\n\t\t\t\t\tmapper.types.enemy.setPath( id, ai.path, null, nearestPathIndex );\n\t\t\t\t} else {\n\t\t\t\t\t// Not on path, move to nearest path tile first.\n\t\t\t\t\tconst path = mapper.ai.doAstar( Loc, nearestPathTile );\n\t\t\t\t\tif ( path ) mapper.types.enemy.setPath( id, path, b8.Path.AnimationMode.ONCE );\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\t/**\n\t\t * CHASE\n\t\t * Move towards target (usually player).\n\t\t */\n\t\tif ( mapper.ai.MODE.CHASE === mode ) {\n\n\t\t\tconst tileGoal = b8.ECS.getComponent( mapper.player, 'Loc' );\n\n\t\t\tif ( tileGoal ) {\n\t\t\t\tconst path = mapper.ai.doAstar( Loc, tileGoal );\n\n\t\t\t\tif ( path ) {\n\t\t\t\t\tmapper.repeatLastValue( path, 12 );\n\t\t\t\t\tmapper.types.enemy.setPath( id, path, b8.Path.AnimationMode.ONCE );\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\t/**\n\t\t * ATTACK\n\t\t * Perform attack action on target.\n\t\t */\n\t\tif ( mapper.ai.MODE.ATTACK === mode ) {\n\n\t\t\tconsole.log( `Think ATTACK mode (${id})` );\n\n\t\t\tmapper.doAttack( id, 'ButtonA' );\n\n\t\t}\n\n\n\t\t/**\n\t\t * FLEE\n\t\t * Move away from target.\n\t\t */\n\t\tif ( mapper.ai.MODE.FLEE === mode ) {\n\n\t\t\tconst tile = mapper.ai.randomNearbyTile( Loc, 4 );\n\n\t\t\tif ( tile ) {\n\t\t\t\tconst path = mapper.ai.doAstar( Loc, tile );\n\t\t\t\tif ( path ) mapper.types.enemy.setPath( id, path, b8.Path.AnimationMode.ONCE );\n\t\t\t}\n\n\t\t}\n\n\t\tif ( mapper.ai.MODE.LOOT === mode ) {\n\n\t\t\tconsole.log( `Think LOOT mode (${id})` );\n\n\t\t}\n\n\t\tif ( mapper.ai.MODE.IDLE === mode ) {\n\n\t\t\tconsole.log( `Think IDLE mode (${id})` );\n\n\t\t}\n\n\n\t}\n\n};\nmapper.systems.bomb = async function( dt ) {\n\n\tconst bombs = b8.ECS.query( 'Bomb' );\n\n\tconst color = mapper.types.bomb.color;\n\tconst flickerColor = mapper.types.bomb.flickerColor;\n\n\tfor ( const id of bombs ) {\n\n\t\tconst bomb = b8.ECS.getComponent( id, 'Bomb' );\n\n\t\t// Skip if fuse not ignited.\n\t\tif ( bomb.fuseTime === false ) continue;\n\n\t\t// Decrease fuse time.\n\t\tbomb.fuseTime -= dt;\n\n\t\t// Make bomb flicker as fuse gets shorter.\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\t\tif ( bomb.fuseTime > 5 ) {\n\t\t\tsprite.fg = color;\n\t\t} else if ( bomb.fuseTime > 2.5 ) {\n\t\t\tsprite.fg = ( Math.floor( bomb.fuseTime * 2 ) % 2 === 0 ) ? color : flickerColor;\n\t\t} else if ( bomb.fuseTime > 1 ) {\n\t\t\tsprite.fg = ( Math.floor( bomb.fuseTime * 4 ) % 2 === 0 ) ? color : flickerColor;\n\t\t} else if ( bomb.fuseTime > 0 ) {\n\t\t\tsprite.fg = ( Math.floor( bomb.fuseTime * 10 ) % 2 === 0 ) ? color : flickerColor;\n\t\t}\n\n\t\t// Explode bomb when fuse reaches zero.\n\t\tif ( bomb.fuseTime <= 0 ) {\n\n\t\t\tconst bombLoc = b8.ECS.getComponent( id, 'Loc' );\n\n\t\t\t// Spawn explosion VFX\n\t\t\tmapper.types.vfx.spawn( bombLoc.col, bombLoc.row, { id: 'explosion', fg: 9 } );\n\n\t\t\t// Explode bomb\n\t\t\tawait mapper.types.bomb.explode( id );\n\n\t\t\t// Remove bomb entity\n\t\t\tb8.ECS.removeEntity( id );\n\n\t\t\t// Screen shake.\n\t\t\tb8.Renderer.shakeScreen();\n\n\t\t\t// Explode sound effect.\n\t\t\tb8.Sfx.play( 'weapon/explode/013' );\n\n\t\t}\n\n\t};\n\n};\nmapper.systems.characterAnimation = function( dt ) {\n\n\tconst anims = b8.ECS.query( 'CharacterAnimation' );\n\tif ( !anims ) return;\n\n\t// Loop through anims.\n\tfor ( const id of anims ) {\n\n\t\tconst anim = b8.ECS.getComponent( id, 'CharacterAnimation' );\n\t\tif ( !anim ) continue;\n\n\t\tif ( anim.duration > 0 ) {\n\n\t\t\tanim.duration -= dt;\n\t\t\tif ( anim.duration <= 0 ) {\n\n\t\t\t\tlet defaultAnimation = anim.default || '';\n\t\t\t\tconst direction = b8.ECS.getComponent( id, 'Direction' );\n\n\t\t\t\tif ( direction ) {\n\t\t\t\t\tconst directionNames = {\n\t\t\t\t\t\t'0,1': '',\n\t\t\t\t\t\t'0,-1': '-up',\n\t\t\t\t\t\t'1,0': '-right',\n\t\t\t\t\t\t'-1,0': '-left'\n\t\t\t\t\t};\n\t\t\t\t\tconst directionName = directionNames[ `${direction.dx},${direction.dy}` ] || '';\n\t\t\t\t\tdefaultAnimation = defaultAnimation + directionName;\n\t\t\t\t}\n\n\t\t\t\tanim.name = defaultAnimation;\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\nmapper.systems.fireSmall = async function( dt ) {\n\n\tconst damagePerSecond = mapper.types.fireSmall.damagePerSecond;\n\n\tconst smallFires = b8.ECS.query( 'FireSmall' );\n\n\tsmallFires.forEach(\n\t\t( entityId ) => {\n\n\t\t\tconst smallFire = b8.ECS.getComponent( entityId, 'FireSmall' );\n\t\t\tconst loc = b8.ECS.getComponent( entityId, 'Loc' );\n\t\t\tconst parentLoc = b8.ECS.getComponent( smallFire.parent, 'Loc' );\n\n\t\t\t// Keep the small fire at the parent's location\n\t\t\tif ( parentLoc ) {\n\t\t\t\tloc.col = parentLoc.col;\n\t\t\t\tloc.row = parentLoc.row;\n\t\t\t}\n\n\t\t\t// Get entities at the fire's location\n\t\t\tconst parentHealth = b8.ECS.getComponent( smallFire.parent, 'Health' );\n\t\t\tif ( parentHealth ) {\n\t\t\t\tparentHealth.value -= damagePerSecond * dt;\n\t\t\t\t// If parent dies, extinguish the small fire.\n\t\t\t\tif ( parentHealth.value < 0 ) smallFire.duration = 0;\n\t\t\t}\n\n\t\t\t// Reduce the fire's duration\n\t\t\tsmallFire.duration -= dt;\n\t\t\tif ( smallFire.duration <= 0 ) {\n\t\t\t\tb8.ECS.removeEntity( entityId );\n\t\t\t\tb8.ECS.removeComponent( smallFire.parent, 'OnFire' );\n\t\t\t\tif ( parentHealth ) parentHealth.value = Math.floor( parentHealth.value );\n\t\t\t}\n\n\t\t}\n\t);\n\n};\n\n\nmapper.systems.fire = async function( dt ) {\n\n\tconst fires = b8.ECS.query( 'Fire', 'Loc' );\n\n\tfires.forEach(\n\t\t( fireId ) => {\n\n\t\t\tconst fire = b8.ECS.getComponent( fireId, 'Fire' );\n\t\t\tconst loc = b8.ECS.getComponent( fireId, 'Loc' );\n\n\t\t\t// Reduce the fire's duration\n\t\t\tif ( fire.duration !== Infinity ) {\n\n\t\t\t\tfire.duration -= dt;\n\n\t\t\t\tif ( fire.duration <= 0 ) {\n\t\t\t\t\tb8.ECS.removeEntity( fireId ); // Extinguish the fire\n\t\t\t\t\tmapper.types.vfx.spawn(\n\t\t\t\t\t\tloc.col, loc.row,\n\t\t\t\t\t\t{ id: 'shrink', fg: 9 }\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Apply damage or custom burn behavior to entities at the fire's location\n\t\t\tconst entitiesAtLocation = b8.ECS.entitiesAt( loc.col, loc.row );\n\t\t\tentitiesAtLocation.forEach(\n\t\t\t\t( entityId ) => {\n\n\t\t\t\t\t// Skip the fire itself\n\t\t\t\t\tif ( entityId === fireId ) return;\n\n\t\t\t\t\t// Set entities on fire if they have a health component.\n\t\t\t\t\t// This suggests they are living things that can burn (enemy/ player/ npc).\n\t\t\t\t\t// We spawn a small fire effect on them to indicate this.\n\t\t\t\t\tif ( b8.ECS.hasComponent( entityId, 'Health' ) ) {\n\n\t\t\t\t\t\t// Only spawn a FireSmall if the entity doesn't already have one\n\t\t\t\t\t\tif ( !b8.ECS.hasComponent( entityId, 'OnFire' ) ) {\n\n\t\t\t\t\t\t\tmapper.types.fireSmall.spawn(\n\t\t\t\t\t\t\t\tloc.col, loc.row,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tparent: entityId,\n\t\t\t\t\t\t\t\t\tduration: 3.0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tb8.ECS.addComponent( entityId, 'OnFire' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmapper.doHandler( entityId, 'burnHandler' );\n\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Heat up nearby flammable entities\n\t\t\tconst nearbyEntities = mapper.entitiesNextTo( fireId );\n\t\t\tnearbyEntities.forEach(\n\t\t\t\t( entityId ) => {\n\n\t\t\t\t\tif ( entityId === fireId ) return; // Skip the fire itself\n\n\t\t\t\t\tconst flammable = b8.ECS.getComponent( entityId, 'Flammable' );\n\t\t\t\t\tif ( flammable ) {\n\t\t\t\t\t\tflammable.temperature = ( flammable.temperature || 0 ) + 70 * dt;\n\t\t\t\t\t}\n\n\t\t\t\t\tmapper.doHandler( entityId, 'burnHandler' );\n\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t);\n\n};\nmapper.systems.flammable = async function( dt ) {\n\n\tconst flammables = b8.ECS.query( 'Flammable' );\n\n\tflammables.forEach(\n\t\t( entityId ) => {\n\n\t\t\tconst flammable = b8.ECS.getComponent( entityId, 'Flammable' );\n\n\t\t\t// Check if the flammable entity should catch fire.\n\t\t\tif ( flammable.temperature >= 100 ) {\n\n\t\t\t\tconst location = b8.ECS.getComponent( entityId, 'Loc' );\n\t\t\t\tmapper.types.fire.spawn(\n\t\t\t\t\tlocation.col,\n\t\t\t\t\tlocation.row\n\t\t\t\t);\n\n\t\t\t\tb8.ECS.removeEntity( entityId ); // The entity catches fire\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Cool down flammable entities that are not on fire.\n\t\t\tflammable.temperature = Math.max( 0, ( flammable.temperature || 0 ) - 10 * dt );\n\n\t\t}\n\t);\n};\n\nmapper.systems.health = async function( dt ) {\n\n\tconst entities = b8.ECS.query( 'Health' );\n\n\tentities.forEach(\n\t\tasync ( entityId ) => {\n\n\t\t\tconst health = b8.ECS.getComponent( entityId, 'Health' );\n\n\t\t\t// Reduce cooldown timer.\n\t\t\t// If still in cooldown, skip further processing.\n\t\t\thealth.cooldownTimer = Math.max( 0, ( health.cooldownTimer || 0 ) - dt );\n\t\t\tif ( health.cooldownTimer > 0 ) return;\n\n\t\t\tif ( health.value <= 0 ) {\n\n\t\t\t\t// Spawn defeat VFX.\n\t\t\t\tconst loc = b8.ECS.getComponent( entityId, 'Loc' );\n\t\t\t\tif ( loc ) {\n\t\t\t\t\tmapper.types.vfx.spawn(\n\t\t\t\t\t\tloc.col, loc.row,\n\t\t\t\t\t\t{ id: 'skull', fg: 2, bg: 0, offsetTime: 200 }\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Small pause on defeat.\n\t\t\t\t// mapper.updateMoveDelay( 0.6 );\n\n\t\t\t\t// Kill the entity unless it's the player.\n\t\t\t\tif ( entityId !== mapper.player ) {\n\t\t\t\t\tb8.ECS.removeEntity( entityId );\n\t\t\t\t} else {\n\t\t\t\t\tawait b8.Async.wait( 1 );\n\t\t\t\t\tb8.Scene.set( 'gameover' );\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t);\n\n};\n\n/**\n * Path Follower System\n *\n * Moves entities along predefined paths based on their PathFollower component.\n */\nmapper.systems.pathFollower = async function( dt ) {\n\n\tconst ids = b8.ECS.query( \"Loc\", \"PathFollower\" );\n\n\tfor ( const id of ids ) {\n\n\t\tconst pf = b8.ECS.getComponent( id, \"PathFollower\" );\n\t\tconst Loc = b8.ECS.getComponent( id, \"Loc\" );\n\n\t\t// Skip if no steps defined.\n\t\tif ( !pf || !pf.steps.length ) continue;\n\n\t\t// Update timer.\n\t\tpf.timer -= dt;\n\t\tif ( pf.timer > 0 ) continue;\n\t\tpf.timer = mapper.CONFIG.moveDelay * 2;\n\n\t\t// Check if step is a pause (stay in place).\n\t\tconst step = pf.steps[ pf.index ];\n\t\tconst isPauseStep = ( Loc.col === step.col && Loc.row === step.row );\n\n\t\t// Determine if movement can occur.\n\t\tlet canMove = isPauseStep;\n\n\t\t// Face command - always allowed.\n\t\tif ( step.dir && step.dir[ 0 ] === 'F' ) canMove = true;\n\n\t\t// Check if step is not blocked by collision.\n\t\tif ( !isPauseStep && mapper.collision.isFree( step.col, step.row ) ) canMove = true;\n\n\t\t// If movement is blocked, skip to next character.\n\t\tif ( !canMove ) continue;\n\n\t\tconst directionVector = {\n\t\t\tdx: step.col - Loc.col,\n\t\t\tdy: step.row - Loc.row\n\t\t};\n\n\t\t// Move to next step\n\t\tb8.ECS.setComponent( id, \"Direction\", directionVector );\n\t\tb8.ECS.setLoc( id, step.col, step.row );\n\n\t\tif ( !step.dir ) step.dir = mapper.pathFollower.getFaceDirection( directionVector );\n\n\t\t// Advance to next step index based on mode\n\t\tmapper.pathFollower.advancePathIndex( pf );\n\n\t\t// Update animation based on direction\n\t\tconst anim = b8.ECS.getComponent( id, \"CharacterAnimation\" );\n\t\tanim.duration = 0.5;\n\n\t\tif ( mapper.pathFollower.animationMap[ step.dir ] ) {\n\t\t\tlet dir = step.dir;\n\t\t\t// Invert the direction for reverse movement.\n\t\t\tif ( pf.dirStep === -1 ) dir = mapper.pathFollower.animationInverse[ step.dir ] || step.dir;\n\t\t\tanim.name = mapper.pathFollower.animationMap[ dir ];\n\t\t}\n\n\t\tif ( pf.mode === b8.Path.AnimationMode.ONCE && pf.index >= pf.steps.length - 1 ) {\n\t\t\tb8.ECS.removeComponent( id, \"PathFollower\" );\n\t\t}\n\n\t}\n};\n\n/**\n * Mapper system: Pickups\n *\n * Handles player picking up items in the game world.\n */\nmapper.systems.pickup = function() {\n\n\tconst playerId = mapper.player;\n\tconst pLoc = b8.ECS.getComponent( playerId, 'Loc' );\n\n\t// Get all pickup entities.\n\tconst pickupIds = b8.ECS.query( 'Pickup', 'Loc' );\n\n\t// Process each pickup and check their location.\n\tpickupIds.forEach(\n\t\t( id ) => {\n\n\t\t\t// Check if at same location as player.\n\t\t\tconst loc = b8.ECS.getComponent( id, 'Loc' );\n\t\t\tif ( loc.col !== pLoc.col || loc.row !== pLoc.row ) return;\n\n\t\t\t// Handle the pickup.\n\t\t\tconst pickup = b8.ECS.getComponent( id, 'Pickup' );\n\n\t\t\tmapper.giveRewards(\n\t\t\t\tplayerId,\n\t\t\t\t[ { type: pickup.type, props: pickup.props } ]\n\t\t\t);\n\n\t\t\t// Consume (remove from world).\n\t\t\tif ( pickup.consume ) {\n\n\t\t\t\t// Remove entity.\n\t\t\t\tb8.ECS.removeEntity( id );\n\n\t\t\t\t// Remove map object.\n\t\t\t\tmapper.removeObjectAt( loc.col, loc.row, pickup.type );\n\n\t\t\t}\n\n\t\t}\n\t);\n\n};\n\n/**\n * Portal system\n *\n */\n\n/**\n * Check for portal at given location.\n * If found, handle teleportation.\n *\n * @param {number} col - The column to check.\n * @param {number} row - The row to check.\n * @returns {Promise<boolean>} True if portal handled, false otherwise.\n */\nmapper.systems.tryPortal = async function( col, row ) {\n\n\tconst id = b8.ECS.entitiesAt( col, row );\n\n\tif ( !id ) return false;\n\n\tfor ( const entityId of id ) {\n\t\tconst portal = b8.ECS.getComponent( entityId, 'Portal' );\n\t\treturn mapper.systems.handlePortal( portal );\n\t}\n\n\treturn false;\n\n}\n\n\n/**\n * Handle portal teleportation.\n *\n * @param {Object} portal - The portal component.\n * @returns {Promise<boolean>} True if portal handled, false otherwise.\n */\nmapper.systems.handlePortal = async function( portal ) {\n\n\tif ( !portal ) return false;\n\tif ( '' === portal.target ) return false;\n\n\t// Find portal with the matching name.\n\n\tconst doorways = mapper.helpers.getObjectsByType( 'door' );\n\tconst targetDoorway = doorways.find(\n\t\t( door ) => {\n\t\t\treturn door.props.name === portal.target;\n\t\t}\n\t);\n\n\t// Teleport player to target doorway.\n\tif ( targetDoorway ) {\n\t\tawait b8.Async.wait( 0.1 );\n\t\tmapper.setCurrentMap( targetDoorway.mapId );\n\t\tmapper.lastPosition = { col: targetDoorway.x, row: targetDoorway.y, map: targetDoorway.mapId };\n\t\tb8.ECS.setLoc( mapper.player, targetDoorway.x, targetDoorway.y );\n\t}\n\n\treturn false; // Allow stepping onto the portal\n\n};\n\n\nmapper.systems.tryPushing = ( col, row, dx, dy ) => {\n\n\tconst hitX = col + dx;\n\tconst hitY = row + dy;\n\n\tfor ( const id of b8.ECS.entitiesAt( hitX, hitY ) ) {\n\n\t\t// If not a solid object, or pushable, skip.\n\t\tif ( !b8.ECS.hasComponent( id, 'Solid' ) ) continue;\n\t\tif ( !b8.ECS.hasComponent( id, 'Pushable' ) ) continue;\n\n\t\tconst loc = b8.ECS.getComponent( id, 'Loc' );\n\t\tconst newCol = loc.col + dx;\n\t\tconst newRow = loc.row + dy;\n\n\t\tconst blocked =\n\t\t\t!mapper.collision.isWalkable( newCol, newRow ) ||\n\t\t\tb8.ECS.entitiesAt( newCol, newRow ).some( e => b8.ECS.hasComponent( e, 'Solid' ) );\n\n\t\tif ( !blocked ) {\n\t\t\t// move the pushable thing.\n\t\t\tb8.ECS.setLoc( id, newCol, newRow );\n\n\t\t\tb8.Sfx.play( 'fx/action/drag' );\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\treturn false;\n\n};\n\n\n\nmapper.systems.tryPulling = ( col, row, dx, dy, playerId ) => {\n\n\tconst hitCol = col + dx;\n\tconst hitRow = row + dy;\n\n\tfor ( const id of b8.ECS.entitiesAt( hitCol, hitRow ) ) {\n\n\t\tif ( !b8.ECS.hasComponent( id, 'Solid' ) ) continue;\n\t\tif ( !b8.ECS.hasComponent( id, 'Pushable' ) ) continue; // now covers pull\n\n\t\tconst backCol = col - dx;\n\t\tconst backRow = row - dy;\n\t\tif ( !mapper.collision.isWalkable( backCol, backRow ) ||\n\t\t\tb8.ECS.entitiesAt( backCol, backRow ).some( e => b8.ECS.hasComponent( e, 'Solid' ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Move target into player's tile, move player back\n\t\tb8.ECS.setLoc( id, col, row );\n\t\tb8.ECS.setLoc( playerId, backCol, backRow );\n\n\t\tmapper.setPlayerWalkAnimation( playerId, dx, dy );\n\n\t\tb8.Sfx.play( 'fx/action/drag' );\n\n\t\treturn true;\n\n\t}\n\n\treturn false;\n\n};\n\n\nmapper.systems.sprite = function( dt ) {\n\n\tconst ids = b8.ECS.query( 'Sprite' );\n\n\tfor ( const id of ids ) {\n\n\t\tconst spr = b8.ECS.getComponent( id, 'Sprite' );\n\n\t\tif ( spr.nudgeCol ) { spr.nudgeCol = spr.nudgeCol * 0.75; }\n\t\tif ( spr.nudgeRow ) { spr.nudgeRow = spr.nudgeRow * 0.75; }\n\n\t}\n\n};\n\nmapper.systems.vfx = async function( dt ) {\n\n\tconst list = b8.ECS.query( 'Vfx', 'Sprite' );\n\n\tfor ( const id of list ) {\n\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\t\tif ( b8.Vfx.shouldLoop( sprite.id, sprite.startTime ) ) continue;\n\n\t\tb8.ECS.removeEntity( id );\n\n\t}\n\n}\n\nmapper.types.skeleton = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\n\n\t\t\t}\n\t\t);\n\n\t},\n\n\tpickupHandler: function( playerId, pickup ) {\n\t},\n\n\ttriggerHandler: function( playerId, id ) {\n\t},\n\n\tonCharacterCollision: function( id, newCol, newRow, dx, dy ) {\n\t},\n\n\tburnHandler: function( id, fire ) {\n\t},\n\n};\n\nmapper.types.bomb = {\n\n\tcolor: 8,\n\tflickerColor: 15,\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'bomb' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 283,\n\t\t\t\t\tfg: mapper.types.bomb.color,\n\t\t\t\t\tbg: 0,\n\t\t\t\t\tdepth: 10\n\t\t\t\t},\n\t\t\t\tSolid: {},\n\t\t\t\tPushable: {},\n\t\t\t\tAction: {\n\t\t\t\t\tButtonB: 'pull',\n\t\t\t\t\tButtonA: 'ignite'\n\t\t\t\t},\n\t\t\t\tBomb: {\n\t\t\t\t\tfuseTime: false,\n\t\t\t\t\tradius: parseInt( props.radius ) || 1,\n\t\t\t\t\tdamage: 2,\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Handle bomb explosion.\n\t *\n\t * @param {number} bombId - The entity ID of the bomb.\n\t * @returns {Promise<void>} Resolves when the explosion is complete.\n\t */\n\texplode: async function( bombId ) {\n\n\t\tconst bombLoc = b8.ECS.getComponent( bombId, 'Loc' );\n\t\tconst bombComp = b8.ECS.getComponent( bombId, 'Bomb' );\n\n\t\t// Create explosion effect\n\t\t// Loop through tiles in radius.\n\t\tfor ( let dx = -bombComp.radius; dx <= bombComp.radius; dx++ ) {\n\t\t\tfor ( let dy = -bombComp.radius; dy <= bombComp.radius; dy++ ) {\n\n\t\t\t\tconst row = bombLoc.row + dy;\n\t\t\t\tconst col = bombLoc.col + dx;\n\n\t\t\t\t// Spawn fire only on walkable tiles.\n\t\t\t\tif ( !mapper.collision.isWalkable( col, row ) ) continue;\n\t\t\t\tmapper.types.fire.spawn( col, row );\n\n\t\t\t}\n\t\t}\n\n\t},\n\n\n\n\tburnHandler: function( id ) {\n\n\t\tconst bomb = b8.ECS.getComponent( id, 'Bomb' );\n\n\t\tif ( bomb.fuseTime !== false ) return;\n\n\t\tbomb.fuseTime = 2;\n\n\t},\n\n};\nmapper.types.chestOpen = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tconst entitySettings = {\n\t\t\tType: { name: 'chest' },\n\t\t\tLoc: { col, row },\n\t\t\tSprite: {\n\t\t\t\ttile: 271,\n\t\t\t\tfg: props.fg || 15,\n\t\t\t\tbg: props.bg || 0,\n\t\t\t\tdepth: 10\n\t\t\t},\n\t\t\tSolid: {},\n\t\t};\n\n\t\tif ( props.message ) {\n\t\t\tentitySettings.Message = { message: props.message };\n\t\t\tentitySettings.Action = {\n\t\t\t\tButtonA: 'read',\n\t\t\t\tButtonB: 'read'\n\t\t\t};\n\t\t}\n\n\t\treturn b8.ECS.create( entitySettings );\n\n\t},\n\n};\nmapper.types.chest = {\n\n\titems: {\n\t\t0: 'Empty',\n\t\t1: 'Key',\n\t\t2: 'Coin',\n\t\t3: '10 Coins',\n\t\t4: '50 Coins',\n\t\t5: 'Half Heart',\n\t\t6: 'Heart',\n\t\t7: 'Full Heart',\n\t\t// 4: '1 Bomb',\n\t\t// 5: '5 Bombs',\n\t},\n\n\tmessages: {\n\t\t0: \"The chest is empty.\",\n\t\t1: \"You found a key!\",\n\t\t2: \"You found a coin!\",\n\t\t3: \"You found 10 coins!\",\n\t\t4: \"You found 50 coins!\",\n\t\t5: \"You found a half heart!\",\n\t\t6: \"You found a heart!\",\n\t\t7: \"You found a full heart!\",\n\t\t// 4: \"You found a bomb!\",\n\t\t// 5: \"You found 5 bombs!\",\n\t},\n\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tlet items = [];\n\t\tlet foregroundColor = props.fg || 15;\n\t\tlet containsType = '';\n\n\t\tif ( mapper.types.chest.items[ props.contains ] ) {\n\t\t\tcontainsType = mapper.types.chest.items[ props.contains ];\n\t\t}\n\n\t\tif ( containsType === 'Key' ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'key',\n\t\t\t\t\tprops: { name: `key-${foregroundColor}` },\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif ( containsType.endsWith( 'Coins' ) ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'coin',\n\t\t\t\t\tprops: { amount: parseInt( containsType.split( ' ' )[ 0 ], 10 ) }\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif ( containsType === 'Coin' ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'coin',\n\t\t\t\t\tprops: { amount: 1 }\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif ( containsType === 'Half Heart' ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'health',\n\t\t\t\t\tprops: { amount: 1 }\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif ( containsType === 'Heart' ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'health',\n\t\t\t\t\tprops: { amount: 2 }\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif ( containsType === 'Full Heart' ) {\n\t\t\titems.push(\n\t\t\t\t{\n\t\t\t\t\ttype: 'health',\n\t\t\t\t\tprops: { amount: 9999 }\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'chest' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 253,\n\t\t\t\t\tfg: foregroundColor,\n\t\t\t\t\tbg: props.bg || 0,\n\t\t\t\t\tdepth: 10\n\t\t\t\t},\n\t\t\t\tSolid: {},\n\t\t\t\tOpenable: {\n\t\t\t\t\tclosedTile: 253,\n\t\t\t\t\topenedTile: 271,\n\t\t\t\t\tnewType: 'chestOpen',\n\t\t\t\t\tmessage: mapper.types.chest.messages[ props.contains ] || \"The chest is empty.\",\n\t\t\t\t},\n\t\t\t\tMessage: { message: props.message || \"\" },\n\t\t\t\tReward: { items },\n\t\t\t\tAction: {\n\t\t\t\t\tButtonA: 'open',\n\t\t\t\t\tButtonB: 'open'\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n};\nmapper.types.coin = {\n\n\t/**\n\t * Spawn a coin entity.\n\t *\n\t * @param {number} col - The column to spawn the coin at.\n\t * @param {number} row - The row to spawn the coin at.\n\t * @param {Object} props - Additional properties for the coin.\n\t * @returns {number} The entity ID of the spawned coin.\n\t */\n\tspawn: function( col, row, props = {} ) {\n\n\t\treturn mapper.types.pickup.spawn(\n\t\t\tcol,\n\t\t\trow,\n\t\t\t{\n\t\t\t\ttype: 'coin',\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: parseInt( mapper.settings.coin ) || 266,\n\t\t\t\t\tfg: mapper.settings.coinColor || 14,\n\t\t\t\t\tbg: props.bg || 0\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Handle the player picking up the coin.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @param {Object} pickup - The Pickup component of the coin.\n\t * @returns {void}\n\t */\n\tpickupHandler: function( playerId, pickup ) {\n\n\t\tb8.Inventory.add( 'coin', pickup?.props?.amount || 1 );\n\t\tb8.Sfx.play( 'game/coin/002' );\n\n\t},\n\n};\n\nmapper.types.crate = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'crate' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 352,\n\t\t\t\t\tfg: props.fg || 15,\n\t\t\t\t\tbg: props.bg || 0,\n\t\t\t\t\tdepth: 10\n\t\t\t\t},\n\t\t\t\tSolid: {},\n\t\t\t\tPushable: {},\n\t\t\t\tAction: { ButtonB: 'pull' },\n\t\t\t\tFlammable: {\n\t\t\t\t\ttemperature: 20,\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t},\n\n};\n\nmapper.types.doorOpen = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tconst doorProps = {\n\t\t\tType: { name: 'door' },\n\t\t\tLoc: { col, row },\n\t\t\tSprite: {\n\t\t\t\ttile: 216,\n\t\t\t\tfg: props.fg || 14,\n\t\t\t\tbg: props.bg || 0\n\t\t\t},\n\t\t\tPortal: {\n\t\t\t\tname: props.name || null,\n\t\t\t\ttarget: props.leadsTo || ''\n\t\t\t},\n\t\t};\n\n\t\treturn b8.ECS.create( doorProps );\n\n\t},\n\n\n\tonCharacterCollision: function( id, newCol, newRow, dx, dy ) {\n\n\t\t// Check if the player is trying to step onto a portal.\n\t\tmapper.systems.tryPortal( newCol, newRow );\n\t\treturn false;\n\n\t},\n\n};\n\nmapper.types.doorStairs = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tconst icon = props.icon || 197;\n\n\t\tconst stairsProps = {\n\t\t\tType: { name: 'doorStairs' },\n\t\t\tLoc: { col, row },\n\t\t\tSprite: {\n\t\t\t\ttile: icon,\n\t\t\t\tfg: props.fg || 14,\n\t\t\t\tbg: props.bg || 0\n\t\t\t},\n\t\t\tPortal: {\n\t\t\t\tname: props.name || null,\n\t\t\t\ttarget: props.leadsTo || ''\n\t\t\t},\n\t\t};\n\n\t\treturn b8.ECS.create( stairsProps );\n\n\t},\n\n\n\tonCharacterCollision: function( id, newCol, newRow, dx, dy ) {\n\n\t\t// Check if the player is trying to step onto a portal.\n\t\tmapper.systems.tryPortal( newCol, newRow );\n\t\treturn false;\n\n\t},\n\n};\n\nmapper.types.door = {\n\n\tTILE_DOOR_OPEN: 216,\n\tTILE_DOOR_DEFAULT: 219,\n\n\tFLAMMABLE_DOOR_TILES: [ 221 ],\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tconst icon = parseInt( props.icon ) || mapper.types.door.TILE_DOOR_DEFAULT;\n\n\t\tconst doorProps = {\n\t\t\tType: { name: 'door' },\n\t\t\tLoc: { col, row },\n\t\t\tSprite: {\n\t\t\t\ttile: icon,\n\t\t\t\tfg: props.fg || 14,\n\t\t\t\tbg: props.bg || 0\n\t\t\t},\n\t\t\tPortal: {\n\t\t\t\tname: props.name || null,\n\t\t\t\ttarget: props.leadsTo || ''\n\t\t\t},\n\t\t};\n\n\t\tif ( icon !== mapper.types.door.TILE_DOOR_OPEN ) {\n\t\t\tdoorProps.Solid = {};\n\t\t}\n\n\t\tif ( mapper.types.door.FLAMMABLE_DOOR_TILES.includes( icon ) ) {\n\t\t\tdoorProps.Flammable = {\n\t\t\t\ttemperature: 0,\n\t\t\t};\n\t\t}\n\n\t\treturn b8.ECS.create( doorProps );\n\n\t},\n\n\n\tonCharacterCollision: function( id, newCol, newRow, dx, dy ) {\n\n\t\t// If the door is open, allow passing through.\n\t\tif ( !b8.ECS.hasComponent( id, 'Solid' ) ) {\n\n\t\t\t// Check if the player is trying to step onto a portal.\n\t\t\tmapper.systems.tryPortal( newCol, newRow );\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\t\tconst keyName = `key-${sprite.fg ?? \"default\"}`;\n\n\t\tif ( b8.Inventory.has( keyName ) ) {\n\t\t\tmapper.types.door.openDoor( id, sprite );\n\t\t\treturn true;\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\n\t/**\n\t * Open the door by changing its sprite and removing solid component.\n\t *\n\t * @param {number} id - The entity ID of the door.\n\t * @param {Object} sprite - The Sprite component of the door.\n\t * @returns {void}\n\t */\n\topenDoor: function( id, sprite ) {\n\n\t\tsprite.tile = mapper.types.door.TILE_DOOR_OPEN;\n\n\t\t// Remove solid component.\n\t\tb8.ECS.removeComponent( id, 'Solid' );\n\n\t\t// Remove flammable component to prevent re-burning.\n\t\tb8.ECS.removeComponent( id, 'Flammable' );\n\n\t\tb8.Sfx.play( 'ui/click/004' );\n\n\t\tconst loc = b8.ECS.getComponent( id, 'Loc' );\n\n\t\tmapper.changeObjectTypeAt(\n\t\t\tloc.col,\n\t\t\tloc.row,\n\t\t\t'door',\n\t\t\t'doorOpen'\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Handle burning of door entities.\n\t *\n\t * @param {number} id - The entity ID of the door.\n\t * @returns {boolean} False to prevent removal of the door entity.\n\t */\n\tburnHandler: function( id ) {\n\n\t\t// Change sprite to open door.\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\n\t\t// Ignore open doors.\n\t\tif ( sprite.tile === mapper.types.door.TILE_DOOR_OPEN ) return;\n\n\t\tmapper.types.door.openDoor( id, sprite );\n\n\t\t// Spawn fire at door location.\n\t\tconst loc = b8.ECS.getComponent( id, 'Loc' );\n\n\t\tmapper.types.fire.spawn(\n\t\t\tloc.col,\n\t\t\tloc.row\n\t\t);\n\n\t\t// Do not remove the door entity.\n\t\treturn false;\n\n\t},\n\n};\n\nmapper.types.enemy = {\n\n\t// Properties [ health, attack, color ]\n\tdifficulties: {\n\t\t'Easy': [ 3, 1, 11 ],\n\t\t'Medium': [ 5, 2, 9 ],\n\t\t'Hard': [ 8, 3, 8 ],\n\t},\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tconst initialDirection = 'D';\n\n\t\tconst difficulty = props.health || 'Easy';\n\t\tconst [ health, attack, color ] = mapper.types.enemy.difficulties[ difficulty ] || mapper.types.enemy.difficulties[ 'Easy' ];\n\n\t\t/**\n\t\t * Create enemy character entity.\n\t\t */\n\t\tconst characterProperties = {\n\t\t\tType: { name: 'enemy' },\n\t\t\tLoc: { col, row },\n\t\t\tDirection: { dx: 0, dy: 1 }, // initial 'D'\n\t\t\tSprite: {\n\t\t\t\ttype: 'actor',\n\t\t\t\ttile: parseInt( props.actor ) || 6,\n\t\t\t\tfg: color || 15,\n\t\t\t\tbg: 0,\n\t\t\t\tdepth: 50,\n\t\t\t},\n\t\t\tSolid: {},\n\t\t\tAI: {\n\t\t\t\tmode: mapper.ai.MODE.NONE,\t\t// current intent: patrol|chase|attack|flee|loot|idle\n\t\t\t\tstartLoc: { col, row },\t\t\t// starting location for patrols\n\t\t\t\ttargetId: mapper.player,\t\t// entity id (player, item, etc)\n\t\t\t\tprops: {\n\t\t\t\t\tcanLoot: false,\n\t\t\t\t\tcanDrop: false,\n\t\t\t\t\tviewRange: 5\n\t\t\t\t},\n\t\t\t},\n\t\t\tCharacterAnimation: {\n\t\t\t\tname: 'idle',\n\t\t\t\tdefault: 'idle',\n\t\t\t\tduration: 0,\n\t\t\t},\n\t\t\tHealth: {\n\t\t\t\tvalue: health || 3,\n\t\t\t\tmax: health || 3,\n\t\t\t\tcooldown: mapper.CONFIG.healthCooldown || 1.0,\n\t\t\t},\n\t\t\tAttack: {\n\t\t\t\tvalue: attack || 1\n\t\t\t},\n\t\t\tAttackTarget: {},\n\t\t\tAction: { ButtonA: 'attack' }\n\t\t};\n\n\t\tlet steps = [];\n\n\t\t// Add PathFollower component if a path is defined\n\t\tif ( props.path && b8.Path.validPathSyntax( props.path ) ) {\n\n\t\t\tsteps = b8.Path.parseCode(\n\t\t\t\tprops.path,\n\t\t\t\tcol,\t\t\t\t// startCol\n\t\t\t\trow,\t\t\t\t// startRow\n\t\t\t\tinitialDirection\t// initialDir\n\t\t\t);\n\n\t\t\tcharacterProperties.AI.path = steps;\n\n\t\t};\n\n\t\tconst id = b8.ECS.create( characterProperties );\n\n\t\treturn id;\n\n\t},\n\n\n\tsetPath: function( id, steps, animationMode = null, index = 0 ) {\n\n\t\t// Determine animation mode if not provided.\n\t\tif ( !animationMode || animationMode === null ) {\n\n\t\t\tconst Loc = b8.ECS.getComponent( id, 'Loc' );\n\t\t\tanimationMode = b8.Path.AnimationMode.PINGPONG;\n\n\t\t\tconst lastStep = steps.length - 1;\n\t\t\tif ( steps[ lastStep ].col === Loc.col && steps[ lastStep ].row === Loc.row ) {\n\t\t\t\tanimationMode = b8.Path.AnimationMode.LOOP;\n\t\t\t}\n\n\t\t}\n\n\t\t// Set PathFollower component.\n\t\tb8.ECS.setComponent(\n\t\t\tid,\n\t\t\t'PathFollower',\n\t\t\t{\n\t\t\t\tsteps,\n\t\t\t\tindex,\n\t\t\t\tmode: animationMode,\n\t\t\t\tdirStep: 1,\n\t\t\t\ttimer: 0,\n\t\t\t\tstartDir: 'D',\n\t\t\t}\n\t\t);\n\n\t}\n\n};\n\nmapper.types.fireSmall = {\n\n\tdamagePerSecond: 0.75,\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tif ( !props.parent ) return;\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'fire-small' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttype: 'vfx-outline',\n\t\t\t\t\tid: 'fire-small',\n\t\t\t\t\toffsetY: -4,\n\t\t\t\t\tstartTime: b8.Core.getNow(),\n\t\t\t\t\tfg: mapper.types.fire.color,\n\t\t\t\t\tbg: 0,\n\t\t\t\t\tdepth: 100,\n\t\t\t\t},\n\t\t\t\tFireSmall: {\n\t\t\t\t\tduration: props.duration || 3,\n\t\t\t\t\tparent: props.parent,\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t}\n};\nmapper.types.fire = {\n\n\tdamagePerSecond: 3,\n\n\tcolor: 10,\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\t// Prevent multiple fires stacking on the same tile.\n\t\tif ( mapper.hasEntityAt( col, row, 'fire' ) ) return null;\n\n\t\tlet duration = parseInt( props.duration );\n\t\tif ( duration === 0 ) {\n\t\t\tduration = Infinity;\n\t\t} else {\n\t\t\tduration = isNaN( duration ) ? 5 : duration;\n\t\t\tduration += b8.Random.range( 0, 2 );\n\t\t}\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'fire' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttype: 'vfx',\n\t\t\t\t\tid: 'fire',\n\t\t\t\t\tstartTime: b8.Core.getNow() + b8.Random.int( 0, 400 ),\n\t\t\t\t\tfg: mapper.types.fire.color,\n\t\t\t\t\tbg: 0,\n\t\t\t\t},\n\t\t\t\tFire: {\n\t\t\t\t\tduration,\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t}\n};\nmapper.types.healthFull = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\treturn mapper.types.pickup.spawn(\n\t\t\tcol,\n\t\t\trow,\n\t\t\t{\n\t\t\t\ttype: 'health',\n\t\t\t\t// Set this health pickup to a large amount,\n\t\t\t\t// It will fully heal the player.\n\t\t\t\t// The value will be capped at max health in the handler.\n\t\t\t\tprops: { amount: 1000 },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 414,\n\t\t\t\t\tfg: 10,\n\t\t\t\t\tbg: 0\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t// pickupHandler()\n\t// Handled by mapper.types.health.pickupHandler\n\n};\n\nmapper.types.healthHalf = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\treturn mapper.types.pickup.spawn(\n\t\t\tcol,\n\t\t\trow,\n\t\t\t{\n\t\t\t\ttype: 'health',\n\t\t\t\tprops: { amount: 1 },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 416,\n\t\t\t\t\tfg: 8,\n\t\t\t\t\tbg: 0\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t// pickupHandler()\n\t// Handled by mapper.types.health.pickupHandler\n\n};\n\nmapper.types.health = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\treturn mapper.types.pickup.spawn(\n\t\t\tcol,\n\t\t\trow,\n\t\t\t{\n\t\t\t\ttype: 'health',\n\t\t\t\tprops: { amount: 2 },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 415,\n\t\t\t\t\tfg: 8,\n\t\t\t\t\tbg: 0\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Handle the player picking up the health pickup.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @param {Object} pickup - The Pickup component of the health item.\n\t * @returns {void}\n\t */\n\tpickupHandler: function( playerId, pickup ) {\n\n\t\tconst health = b8.ECS.getComponent( playerId, 'Health' );\n\t\thealth.value = Math.min( health.max, health.value + ( pickup.props.amount || 1 ) );\n\n\t},\n\n\n};\n\nmapper.types.key = {\n\n\t/**\n\t * Spawn a key entity at the specified location.\n\t *\n\t * @param {number} col - The column to spawn the key at.\n\t * @param {number} row - The row to spawn the key at.\n\t * @param {Object} props - Additional properties for the key (e.g., fg, bg colors).\n\t * @returns {number} The entity ID of the spawned key.\n\t */\n\tspawn: function( col, row, props = {} ) {\n\n\t\tconst color = props.fg || 14;\n\n\t\treturn mapper.types.pickup.spawn(\n\t\t\tcol,\n\t\t\trow,\n\t\t\t{\n\t\t\t\ttype: 'key',\n\t\t\t\tprops: { name: `key-${color}` },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: 255,\n\t\t\t\t\tfg: props.fg || 14,\n\t\t\t\t\tbg: props.bg || 0\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Handle the player picking up the key.\n\t *\n\t * @param {number} playerId - The entity ID of the player.\n\t * @param {Object} pickup - The Pickup component of the key.\n\t * @returns {void}\n\t */\n\tpickupHandler: function( playerId, pickup ) {\n\n\t\tb8.Inventory.add( pickup.props.name );\n\t\tb8.Sfx.play( 'tone/bloop/006' );\n\n\t},\n\n};\n\nmapper.types.pickup = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tif ( !props.type ) return;\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'pickup' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: props.Sprite.tile ?? 415,\n\t\t\t\t\tfg: props.Sprite.fg ?? 8,\n\t\t\t\t\tbg: props.Sprite.bg ?? 0\n\t\t\t\t},\n\t\t\t\tPickup: {\n\t\t\t\t\t// 'health', 'coin', 'key', etc\n\t\t\t\t\ttype: props.type,\n\t\t\t\t\t// remove after pickup\n\t\t\t\t\tconsume: props.consume ?? true,\n\t\t\t\t\t// Custom attributes for handler function\n\t\t\t\t\tprops: props.props || {}\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n};\n\nmapper.types.player = {\n\n\tspawn: function( col = 0, row = 0, props = {} ) {\n\n\t\tconst player = b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'player' },\n\t\t\t\tLoc: { row: row || 0, col: col || 0 },\n\t\t\t\tDirection: { dx: 0, dy: 1 },\n\t\t\t\tSprite: {\n\t\t\t\t\ttype: 'actor',\n\t\t\t\t\ttile: parseInt( mapper.settings.character ) || 6,\n\t\t\t\t\tfg: parseInt( mapper.settings.characterColor ) || 10,\n\t\t\t\t\tbg: 0,\n\t\t\t\t\tdepth: 100,\n\t\t\t\t},\n\t\t\t\tSolid: {},\n\t\t\t\tCharacterAnimation: {\n\t\t\t\t\tname: 'idle',\n\t\t\t\t\tdefault: 'idle',\n\t\t\t\t\tduration: 0,\n\t\t\t\t},\n\t\t\t\tHealth: {\n\t\t\t\t\tcooldown: mapper.CONFIG.healthCooldown || 1.0,\n\t\t\t\t\tvalue: 6,\n\t\t\t\t\tmax: 12\n\t\t\t\t},\n\t\t\t\tAttack: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\tAttackTarget: {},\n\t\t\t\tAction: { ButtonA: 'attack' },\n\t\t\t}\n\t\t);\n\n\t\treturn player;\n\n\t}\n\n}\nmapper.types.signpost = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'signpost' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tSprite: {\n\t\t\t\t\ttile: props.icon || 252,\n\t\t\t\t\tfg: props.fg || 15,\n\t\t\t\t\tbg: props.bg || 0\n\t\t\t\t},\n\t\t\t\tSolid: {},\n\t\t\t\tMessage: { message: props.message || \"\" },\n\t\t\t\tAction: {\n\t\t\t\t\tButtonA: 'trigger',\n\t\t\t\t\tButtonB: 'read'\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n\n\t/**\n\t * Handle the signpost being triggered (Button A).\n\t *\n\t * @param {number} id - The entity ID of the signpost.\n\t * @returns {void}\n\t */\n\ttriggerHandler: function( playerId, id ) {\n\n\t\tconst sprite = b8.ECS.getComponent( id, 'Sprite' );\n\n\t\t// Quit if not the default signpost.\n\t\tif ( sprite.tile !== 252 ) return;\n\n\t\t// Make the cut in half signpost.\n\t\tsprite.tile = 270;\n\n\t\t// Return if no message to change.\n\t\tif ( !b8.ECS.hasComponent( id, 'Message' ) ) return;\n\n\t\tconst message = b8.ECS.getComponent( id, 'Message' );\n\n\t\t// Change both actions to 'read'.\n\t\tb8.ECS.addComponent( id, 'Action', { ButtonA: 'read', ButtonB: 'read' } );\n\n\t\t// Truncate the front half of the message and prepend ...\n\t\tmessage.message = '... ' + message.message.slice( Math.floor( message.message.length / 2 ) );\n\n\t},\n\n};\n\n\nmapper.types.start = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tmapper.lastPosition = {\n\t\t\tcol,\n\t\t\trow,\n\t\t\tmap: mapper.currentMapId\n\t\t};\n\n\t\tb8.ECS.setLoc( mapper.player, col, row );\n\n\t},\n\n};\n\nmapper.types.vfx = {\n\n\tspawn: function( col, row, props = {} ) {\n\n\t\tif ( !props.id ) return {};\n\n\t\treturn b8.ECS.create(\n\t\t\t{\n\t\t\t\tType: { name: 'vfx' },\n\t\t\t\tLoc: { col, row },\n\t\t\t\tVfx: {},\n\t\t\t\tSprite: {\n\t\t\t\t\ttype: props.type || 'vfx',\n\t\t\t\t\tid: props.id,\n\t\t\t\t\tstartTime: b8.Core.getNow() + ( props.offsetTime || 0 ),\n\t\t\t\t\tfg: parseInt( props.fg ) || 15,\n\t\t\t\t\tbg: parseInt( props.bg ) || 0,\n\t\t\t\t\tnudgeCol: parseInt( props.nudgeCol ) || 0,\n\t\t\t\t\tnudgeRow: parseInt( props.nudgeRow ) || 0,\n\t\t\t\t\tdepth: 101,\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\n\t},\n\n};\n"],
  "mappings": "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",
  "names": ["offsetX", "offsetY", "ai", "Loc"]
}
